"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3444],{3905:(e,a,r)=>{r.d(a,{Zo:()=>s,kt:()=>P});var t=r(7294);function l(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,t)}return r}function p(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach((function(a){l(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function o(e,a){if(null==e)return{};var r,t,l=function(e,a){if(null==e)return{};var r,t,l={},n=Object.keys(e);for(t=0;t<n.length;t++)r=n[t],a.indexOf(r)>=0||(l[r]=e[r]);return l}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)r=n[t],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(l[r]=e[r])}return l}var i=t.createContext({}),d=function(e){var a=t.useContext(i),r=a;return e&&(r="function"==typeof e?e(a):p(p({},a),e)),r},s=function(e){var a=d(e.components);return t.createElement(i.Provider,{value:a},e.children)},u="mdxType",k={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},c=t.forwardRef((function(e,a){var r=e.components,l=e.mdxType,n=e.originalType,i=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=d(r),c=l,P=u["".concat(i,".").concat(c)]||u[c]||k[c]||n;return r?t.createElement(P,p(p({ref:a},s),{},{components:r})):t.createElement(P,p({ref:a},s))}));function P(e,a){var r=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var n=r.length,p=new Array(n);p[0]=c;var o={};for(var i in a)hasOwnProperty.call(a,i)&&(o[i]=a[i]);o.originalType=e,o[u]="string"==typeof e?e:l,p[1]=o;for(var d=2;d<n;d++)p[d]=r[d];return t.createElement.apply(null,p)}return t.createElement.apply(null,r)}c.displayName="MDXCreateElement"},1407:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>i,contentTitle:()=>p,default:()=>u,frontMatter:()=>n,metadata:()=>o,toc:()=>d});var t=r(3117),l=(r(7294),r(3905));const n={title:"Sound.Tidal.ParseBP",slug:"/library/modules/Sound.Tidal.ParseBP"},p=void 0,o={unversionedId:"library/autogenerated/Sound-Tidal-ParseBP/Sound-Tidal-ParseBP",id:"library/autogenerated/Sound-Tidal-ParseBP/Sound-Tidal-ParseBP",title:"Sound.Tidal.ParseBP",description:"\x3c!------------------------------------------------------------------------------",source:"@site/docs/library/autogenerated/Sound-Tidal-ParseBP/Sound-Tidal-ParseBP.mdx",sourceDirName:"library/autogenerated/Sound-Tidal-ParseBP",slug:"/library/modules/Sound.Tidal.ParseBP",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.ParseBP",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/library/autogenerated/Sound-Tidal-ParseBP/Sound-Tidal-ParseBP.mdx",tags:[],version:"current",lastUpdatedBy:"Matthew Kaney",lastUpdatedAt:1673207986,formattedLastUpdatedAt:"Jan 8, 2023",frontMatter:{title:"Sound.Tidal.ParseBP",slug:"/library/modules/Sound.Tidal.ParseBP"},sidebar:"library",previous:{title:"Sound.Tidal.Params",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Params"},next:{title:"Sound.Tidal.Pattern",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Pattern"}},i={},d=[{value:"data",id:"data",level:3},{value:"type",id:"type",level:3},{value:"data",id:"data-1",level:3},{value:"tShowList",id:"tshowlist",level:3},{value:"tShow",id:"tshow",level:3},{value:"toPat",id:"topat",level:3},{value:"resolve_tpat",id:"resolve_tpat",level:3},{value:"resolve_seq",id:"resolve_seq",level:3},{value:"resolve_size",id:"resolve_size",level:3},{value:"steps_tpat",id:"steps_tpat",level:3},{value:"steps_seq",id:"steps_seq",level:3},{value:"steps_size",id:"steps_size",level:3},{value:"parseBP",id:"parsebp",level:3},{value:"parseBP_E",id:"parsebp_e",level:3},{value:"parseTPat",id:"parsetpat",level:3},{value:"cP",id:"cp",level:3},{value:"class",id:"class",level:3},{value:"class",id:"class-1",level:3},{value:"enumFromTo&#39;",id:"enumfromto",level:3},{value:"enumFromThenTo&#39;",id:"enumfromthento",level:3},{value:"type",id:"type-1",level:3},{value:"lexer",id:"lexer",level:3},{value:"braces",id:"braces",level:3},{value:"brackets",id:"brackets",level:3},{value:"parens",id:"parens",level:3},{value:"angles",id:"angles",level:3},{value:"symbol",id:"symbol",level:3},{value:"natural",id:"natural",level:3},{value:"integer",id:"integer",level:3},{value:"decimal",id:"decimal",level:3},{value:"float",id:"float",level:3},{value:"naturalOrFloat",id:"naturalorfloat",level:3},{value:"data",id:"data-2",level:3},{value:"applySign",id:"applysign",level:3},{value:"sign",id:"sign",level:3},{value:"intOrFloat",id:"intorfloat",level:3},{value:"pSequence",id:"psequence",level:3},{value:"pRepeat",id:"prepeat",level:3},{value:"pElongate",id:"pelongate",level:3},{value:"pSingle",id:"psingle",level:3},{value:"pVar",id:"pvar",level:3},{value:"pPart",id:"ppart",level:3},{value:"newSeed",id:"newseed",level:3},{value:"pPolyIn",id:"ppolyin",level:3},{value:"pPolyOut",id:"ppolyout",level:3},{value:"pCharNum",id:"pcharnum",level:3},{value:"pString",id:"pstring",level:3},{value:"wrapPos",id:"wrappos",level:3},{value:"pVocable",id:"pvocable",level:3},{value:"pChar",id:"pchar",level:3},{value:"pDouble",id:"pdouble",level:3},{value:"pDoubleWithoutChord",id:"pdoublewithoutchord",level:3},{value:"pNote",id:"pnote",level:3},{value:"pNoteWithoutChord",id:"pnotewithoutchord",level:3},{value:"pBool",id:"pbool",level:3},{value:"parseIntNote",id:"parseintnote",level:3},{value:"pIntegral",id:"pintegral",level:3},{value:"pIntegralWithoutChord",id:"pintegralwithoutchord",level:3},{value:"parseChord",id:"parsechord",level:3},{value:"parseNote",id:"parsenote",level:3},{value:"fromNote",id:"fromnote",level:3},{value:"pColour",id:"pcolour",level:3},{value:"pMult",id:"pmult",level:3},{value:"pRand",id:"prand",level:3},{value:"pE",id:"pe",level:3},{value:"pRational",id:"prational",level:3},{value:"pRatio",id:"pratio",level:3},{value:"pInteger",id:"pinteger",level:3},{value:"pFloat",id:"pfloat",level:3},{value:"pFraction",id:"pfraction",level:3},{value:"pRatioChar",id:"pratiochar",level:3},{value:"pRatioSingleChar",id:"pratiosinglechar",level:3},{value:"isInt",id:"isint",level:3},{value:"parseModInv",id:"parsemodinv",level:3},{value:"parseModInvNum",id:"parsemodinvnum",level:3},{value:"parseModDrop",id:"parsemoddrop",level:3},{value:"parseModOpen",id:"parsemodopen",level:3},{value:"parseModRange",id:"parsemodrange",level:3},{value:"parseModifiers",id:"parsemodifiers",level:3},{value:"pModifiers",id:"pmodifiers",level:3},{value:"pChord",id:"pchord",level:3}],s={toc:d};function u(e){let{components:a,...r}=e;return(0,l.kt)("wrapper",(0,t.Z)({},s,r,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h3",{id:"data"},"data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"data TidalParseError \n")),(0,l.kt)("h3",{id:"type"},"type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"type MyParser = Parsec String Int \n")),(0,l.kt)("h3",{id:"data-1"},"data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"data TPat a where \n")),(0,l.kt)("p",null,"AST representation of patterns"),(0,l.kt)("h3",{id:"tshowlist"},"tShowList"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"tShowList :: Show a => [TPat a] -> String \n")),(0,l.kt)("h3",{id:"tshow"},"tShow"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"tShow :: Show a => TPat a -> String \n")),(0,l.kt)("h3",{id:"topat"},"toPat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"toPat :: (Parseable a, Enumerable a) => TPat a -> Pattern a \n")),(0,l.kt)("h3",{id:"resolve_tpat"},"resolve_tpat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"resolve_tpat :: (Enumerable a, Parseable a) => TPat a -> (Rational, Pattern a) \n")),(0,l.kt)("h3",{id:"resolve_seq"},"resolve_seq"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"resolve_seq :: (Enumerable a, Parseable a) => [TPat a] -> (Rational, Pattern a) \n")),(0,l.kt)("h3",{id:"resolve_size"},"resolve_size"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"resolve_size :: [TPat a] -> [(Rational, TPat a)] \n")),(0,l.kt)("h3",{id:"steps_tpat"},"steps_tpat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"steps_tpat :: Show a => TPat a -> (Rational, String) \n")),(0,l.kt)("h3",{id:"steps_seq"},"steps_seq"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"steps_seq :: Show a => [TPat a] -> (Rational, String) \n")),(0,l.kt)("h3",{id:"steps_size"},"steps_size"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"steps_size :: Show a => [TPat a] -> [(Rational, String)] \n")),(0,l.kt)("h3",{id:"parsebp"},"parseBP"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseBP :: (Enumerable a, Parseable a) => String -> Either ParseError (Pattern a) \n")),(0,l.kt)("h3",{id:"parsebp_e"},"parseBP_E"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseBP_E :: (Enumerable a, Parseable a) => String -> Pattern a \n")),(0,l.kt)("h3",{id:"parsetpat"},"parseTPat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseTPat :: Parseable a => String -> Either ParseError (TPat a) \n")),(0,l.kt)("h3",{id:"cp"},"cP"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"cP :: (Enumerable a, Parseable a) => String -> Pattern a \n")),(0,l.kt)("h3",{id:"class"},"class"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"class Parseable a where \n")),(0,l.kt)("h3",{id:"class-1"},"class"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"class Enumerable a where \n")),(0,l.kt)("h3",{id:"enumfromto"},"enumFromTo'"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"enumFromTo' :: (Ord a, Enum a) => a -> a -> Pattern a \n")),(0,l.kt)("h3",{id:"enumfromthento"},"enumFromThenTo'"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"enumFromThenTo' :: (Ord a, Enum a, Num a) => a -> a -> a -> Pattern a \n")),(0,l.kt)("h3",{id:"type-1"},"type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"type ColourD = Colour Double \n")),(0,l.kt)("h3",{id:"lexer"},"lexer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"lexer :: GenTokenParser String u Identity \n")),(0,l.kt)("h3",{id:"braces"},"braces"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"braces :: MyParser a -> MyParser a \n")),(0,l.kt)("h3",{id:"brackets"},"brackets"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"brackets :: MyParser a -> MyParser a \n")),(0,l.kt)("h3",{id:"parens"},"parens"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parens :: MyParser a -> MyParser a \n")),(0,l.kt)("h3",{id:"angles"},"angles"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"angles :: MyParser a -> MyParser a \n")),(0,l.kt)("h3",{id:"symbol"},"symbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"symbol :: String -> MyParser String \n")),(0,l.kt)("h3",{id:"natural"},"natural"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"natural :: MyParser Integer \n")),(0,l.kt)("h3",{id:"integer"},"integer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"integer :: MyParser Integer \n")),(0,l.kt)("h3",{id:"decimal"},"decimal"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"decimal :: MyParser Integer \n")),(0,l.kt)("h3",{id:"float"},"float"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"float :: MyParser Double \n")),(0,l.kt)("h3",{id:"naturalorfloat"},"naturalOrFloat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"naturalOrFloat :: MyParser (Either Integer Double) \n")),(0,l.kt)("h3",{id:"data-2"},"data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"data Sign \n")),(0,l.kt)("h3",{id:"applysign"},"applySign"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"applySign :: Num a => Sign -> a -> a \n")),(0,l.kt)("h3",{id:"sign"},"sign"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"sign :: MyParser Sign \n")),(0,l.kt)("h3",{id:"intorfloat"},"intOrFloat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"intOrFloat :: MyParser Double \n")),(0,l.kt)("h3",{id:"psequence"},"pSequence"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pSequence :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"prepeat"},"pRepeat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pRepeat :: TPat a -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"pelongate"},"pElongate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pElongate :: TPat a -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"psingle"},"pSingle"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pSingle :: MyParser (TPat a) -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"pvar"},"pVar"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pVar :: MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"ppart"},"pPart"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pPart :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"newseed"},"newSeed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"newSeed :: MyParser Int \n")),(0,l.kt)("h3",{id:"ppolyin"},"pPolyIn"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pPolyIn :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"ppolyout"},"pPolyOut"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pPolyOut :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"pcharnum"},"pCharNum"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pCharNum :: MyParser Char \n")),(0,l.kt)("h3",{id:"pstring"},"pString"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pString :: MyParser String \n")),(0,l.kt)("h3",{id:"wrappos"},"wrapPos"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"wrapPos :: MyParser (TPat a) -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"pvocable"},"pVocable"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pVocable :: MyParser (TPat String) \n")),(0,l.kt)("h3",{id:"pchar"},"pChar"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pChar :: MyParser (TPat Char) \n")),(0,l.kt)("h3",{id:"pdouble"},"pDouble"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pDouble :: MyParser (TPat Double) \n")),(0,l.kt)("h3",{id:"pdoublewithoutchord"},"pDoubleWithoutChord"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pDoubleWithoutChord :: MyParser (TPat Double) \n")),(0,l.kt)("h3",{id:"pnote"},"pNote"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pNote :: MyParser (TPat Note) \n")),(0,l.kt)("h3",{id:"pnotewithoutchord"},"pNoteWithoutChord"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pNoteWithoutChord :: MyParser (TPat Note) \n")),(0,l.kt)("h3",{id:"pbool"},"pBool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pBool :: MyParser (TPat Bool) \n")),(0,l.kt)("h3",{id:"parseintnote"},"parseIntNote"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseIntNote :: Integral i => MyParser i \n")),(0,l.kt)("h3",{id:"pintegral"},"pIntegral"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pIntegral :: (Integral a, Parseable a, Enumerable a) => MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"pintegralwithoutchord"},"pIntegralWithoutChord"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pIntegralWithoutChord :: (Integral a, Parseable a, Enumerable a) => MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"parsechord"},"parseChord"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseChord :: (Enum a, Num a) => MyParser [a] \n")),(0,l.kt)("h3",{id:"parsenote"},"parseNote"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseNote :: Num a => MyParser a \n")),(0,l.kt)("h3",{id:"fromnote"},"fromNote"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"fromNote :: Num a => Pattern String -> Pattern a \n")),(0,l.kt)("h3",{id:"pcolour"},"pColour"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pColour :: MyParser (TPat ColourD) \n")),(0,l.kt)("h3",{id:"pmult"},"pMult"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pMult :: TPat a -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"prand"},"pRand"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pRand :: TPat a -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"pe"},"pE"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pE :: TPat a -> MyParser (TPat a) \n")),(0,l.kt)("h3",{id:"prational"},"pRational"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pRational :: MyParser (TPat Rational) \n")),(0,l.kt)("h3",{id:"pratio"},"pRatio"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pRatio :: MyParser Rational \n")),(0,l.kt)("h3",{id:"pinteger"},"pInteger"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pInteger :: MyParser Double \n")),(0,l.kt)("h3",{id:"pfloat"},"pFloat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pFloat :: MyParser Double \n")),(0,l.kt)("h3",{id:"pfraction"},"pFraction"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pFraction :: RealFrac a => a -> MyParser Rational \n")),(0,l.kt)("h3",{id:"pratiochar"},"pRatioChar"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pRatioChar :: Fractional a => MyParser a \n")),(0,l.kt)("h3",{id:"pratiosinglechar"},"pRatioSingleChar"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pRatioSingleChar :: Fractional a => Char -> a -> MyParser a \n")),(0,l.kt)("h3",{id:"isint"},"isInt"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"isInt :: RealFrac a => a -> Bool \n")),(0,l.kt)("h3",{id:"parsemodinv"},"parseModInv"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseModInv :: MyParser Modifier \n")),(0,l.kt)("h3",{id:"parsemodinvnum"},"parseModInvNum"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseModInvNum :: MyParser [Modifier] \n")),(0,l.kt)("h3",{id:"parsemoddrop"},"parseModDrop"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseModDrop :: MyParser [Modifier] \n")),(0,l.kt)("h3",{id:"parsemodopen"},"parseModOpen"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseModOpen :: MyParser Modifier \n")),(0,l.kt)("h3",{id:"parsemodrange"},"parseModRange"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseModRange :: MyParser Modifier \n")),(0,l.kt)("h3",{id:"parsemodifiers"},"parseModifiers"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parseModifiers :: MyParser [Modifier] \n")),(0,l.kt)("h3",{id:"pmodifiers"},"pModifiers"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pModifiers :: MyParser (TPat [Modifier]) \n")),(0,l.kt)("h3",{id:"pchord"},"pChord"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"pChord :: (Enum a, Num a, Parseable a, Enumerable a) => TPat a -> MyParser (TPat a) \n")))}u.isMDXComponent=!0}}]);