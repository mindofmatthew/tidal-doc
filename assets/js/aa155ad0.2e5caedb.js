"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1084],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=s(n),h=r,m=u["".concat(p,".").concat(h)]||u[h]||c[h]||l;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=h;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5850:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(3117),r=(n(7294),n(3905));const l={title:"Sound.Tidal.Control",slug:"/library/modules/Sound.Tidal.Control"},i=void 0,o={unversionedId:"library/autogenerated/Sound-Tidal-Control/Sound-Tidal-Control",id:"library/autogenerated/Sound-Tidal-Control/Sound-Tidal-Control",title:"Sound.Tidal.Control",description:"\x3c!------------------------------------------------------------------------------",source:"@site/docs/library/autogenerated/Sound-Tidal-Control/Sound-Tidal-Control.mdx",sourceDirName:"library/autogenerated/Sound-Tidal-Control",slug:"/library/modules/Sound.Tidal.Control",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Control",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/library/autogenerated/Sound-Tidal-Control/Sound-Tidal-Control.mdx",tags:[],version:"current",lastUpdatedBy:"Matthew Kaney",lastUpdatedAt:1673207986,formattedLastUpdatedAt:"Jan 8, 2023",frontMatter:{title:"Sound.Tidal.Control",slug:"/library/modules/Sound.Tidal.Control"},sidebar:"library",previous:{title:"Sound.Tidal.Context",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Context"},next:{title:"Sound.Tidal.Core",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Core"}},p={},s=[{value:"spin",id:"spin",level:3},{value:"_spin",id:"_spin",level:3},{value:"chop",id:"chop",level:3},{value:"chopArc",id:"choparc",level:3},{value:"_chop",id:"_chop",level:3},{value:"striate",id:"striate",level:3},{value:"_striate",id:"_striate",level:3},{value:"mergePlayRange",id:"mergeplayrange",level:3},{value:"striateBy",id:"striateby",level:3},{value:"striate&#39;",id:"striate-1",level:3},{value:"_striateBy",id:"_striateby",level:3},{value:"gap",id:"gap",level:3},{value:"_gap",id:"_gap",level:3},{value:"weave",id:"weave",level:3},{value:"weaveWith",id:"weavewith",level:3},{value:"weave&#39;",id:"weave-1",level:3},{value:"interlace",id:"interlace",level:3},{value:"slice",id:"slice",level:3},{value:"_slice",id:"_slice",level:3},{value:"randslice",id:"randslice",level:3},{value:"_splice",id:"_splice",level:3},{value:"splice",id:"splice",level:3},{value:"loopAt",id:"loopat",level:3},{value:"hurry",id:"hurry",level:3},{value:"smash",id:"smash",level:3},{value:"smash&#39;",id:"smash-1",level:3},{value:"echo",id:"echo",level:3},{value:"_echo",id:"_echo",level:3},{value:"echoWith",id:"echowith",level:3},{value:"_echoWith",id:"_echowith",level:3},{value:"stut",id:"stut",level:3},{value:"_stut",id:"_stut",level:3},{value:"stutWith",id:"stutwith",level:3},{value:"_stutWith",id:"_stutwith",level:3},{value:"stut&#39;",id:"stut-1",level:3},{value:"sec",id:"sec",level:3},{value:"msec",id:"msec",level:3},{value:"trigger",id:"trigger",level:3},{value:"qtrigger",id:"qtrigger",level:3},{value:"qt",id:"qt",level:3},{value:"ctrigger",id:"ctrigger",level:3},{value:"rtrigger",id:"rtrigger",level:3},{value:"ftrigger",id:"ftrigger",level:3},{value:"mtrigger",id:"mtrigger",level:3},{value:"mt",id:"mt",level:3},{value:"triggerWith",id:"triggerwith",level:3},{value:"splat",id:"splat",level:3}],d={toc:s};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"spin"},"spin"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spin :: Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spin"),' will "spin" a layer up a pattern the given number of times,\nwith each successive layer offset in time by an additional ',(0,r.kt)("inlineCode",{parentName:"p"},"1/n")," of a\ncycle, and panned by an additional ",(0,r.kt)("inlineCode",{parentName:"p"},"1/n"),". The result is a pattern that\nseems to spin around. This function works best on multichannel\nsystems."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 3 $ spin 4 $ sound "drum*3 tabla:4 [arpy:2 ~ arpy] [can:2 can:3]"\n')),(0,r.kt)("h3",{id:"_spin"},"_spin"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_spin :: Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"chop"},"chop"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"chop :: Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"chop")," granualizes every sample in place as it is played, turning a pattern of samples into a pattern of sample parts. Use an integer value to specify how many granules each sample is chopped into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chop 16 $ sound "arpy arp feel*4 arpy*4"\n')),(0,r.kt)("p",null,"Different values of ",(0,r.kt)("inlineCode",{parentName:"p"},"chop")," can yield very different results, depending\non the samples used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chop 16 $ sound (samples "arpy*8" (run 16))\nd1 $ chop 32 $ sound (samples "arpy*8" (run 16))\nd1 $ chop 256 $ sound "bd*4 [sn cp] [hh future]*2 [cp feel]"\n')),(0,r.kt)("h3",{id:"choparc"},"chopArc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"chopArc :: Arc -> Int -> [Arc] \n")),(0,r.kt)("h3",{id:"_chop"},"_chop"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_chop :: Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"striate"},"striate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"striate :: Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"Striate is a kind of granulator, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ striate 3 $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"This plays the loop the given number of times, but triggering\nprogressive portions of each sample. So in this case it plays the loop\nthree times, the first time playing the first third of each sample,\nthen the second time playing the second third of each sample, etc..\nWith the highhat samples in the above example it sounds a bit like\nreverb, but it isn't really."),(0,r.kt)("p",null,"You can also use striate with very long samples, to cut it into short\nchunks and pattern those chunks. This is where things get towards\ngranular synthesis. The following cuts a sample into 128 parts, plays\nit over 8 cycles and manipulates those parts by reversing and rotating\nthe loops."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $  slow 8 $ striate 128 $ sound "bev"\n')),(0,r.kt)("h3",{id:"_striate"},"_striate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_striate :: Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"mergeplayrange"},"mergePlayRange"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mergePlayRange :: (Double, Double) -> ValueMap -> ValueMap \n")),(0,r.kt)("h3",{id:"striateby"},"striateBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"striateBy :: Pattern Int -> Pattern Double -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"striateBy")," function is a variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"striate")," with an extra\nparameter, which specifies the length of each part. The ",(0,r.kt)("inlineCode",{parentName:"p"},"striateBy"),"\nfunction still scans across the sample over a single cycle, but if\neach bit is longer, it creates a sort of stuttering effect. For\nexample the following will cut the bev sample into 32 parts, but each\nwill be 1/16th of a sample long:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 32 $ striateBy 32 (1/16) $ sound "bev"\n')),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"striate")," uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," parameters\ninternally. This means that if you're using ",(0,r.kt)("inlineCode",{parentName:"p"},"striate")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"striateBy"),")\nyou probably shouldn't also specify ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),". "),(0,r.kt)("h3",{id:"striate-1"},"striate'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"striate' :: Pattern Int -> Pattern Double -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"DEPRECATED, use ",(0,r.kt)("inlineCode",{parentName:"p"},"striateBy")," instead."),(0,r.kt)("h3",{id:"_striateby"},"_striateBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_striateBy :: Int -> Double -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"gap"},"gap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"gap :: Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"gap")," is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"chop")," in that it granualizes every sample in place as it is played,\nbut every other grain is silent. Use an integer value to specify how many granules\neach sample is chopped into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ gap 8 $ sound "jvbass"\nd1 $ gap 16 $ sound "[jvbass drum:4]"\n')),(0,r.kt)("h3",{id:"_gap"},"_gap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_gap :: Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"weave"},"weave"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"weave :: Time -> ControlPattern -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"weave")," applies a function smoothly over an array of different patterns. It uses an ",(0,r.kt)("inlineCode",{parentName:"p"},"OscPattern")," to\napply the function at different levels to each pattern, creating a weaving effect."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ weave 3 (shape $ sine1) [sound "bd [sn drum:2*2] bd*2 [sn drum:1]", sound "arpy*8 ~"]\n')),(0,r.kt)("h3",{id:"weavewith"},"weaveWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"weaveWith :: Time -> Pattern a -> [Pattern a -> Pattern a] -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"weaveWith")," is similar in that it blends functions at the same time at different amounts over a pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ weaveWith 3 (sound "bd [sn drum:2*2] bd*2 [sn drum:1]") [density 2, (# speed "0.5"), chop 16]\n')),(0,r.kt)("h3",{id:"weave-1"},"weave'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"weave' :: Time -> Pattern a -> [Pattern a -> Pattern a] -> Pattern a \n")),(0,r.kt)("h3",{id:"interlace"},"interlace"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interlace :: ControlPattern -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"(A function that takes two ControlPatterns, and blends them together into\na new ControlPattern. An ControlPattern is basically a pattern of messages to\na synthesiser.)"),(0,r.kt)("p",null,"Shifts between the two given patterns, using distortion."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ interlace (sound  "bd sn kurt") (every 3 rev $ sound  "bd sn:2")\n')),(0,r.kt)("h3",{id:"slice"},"slice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"slice :: Pattern Int -> Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"_slice"},"_slice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_slice :: Int -> Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"randslice"},"randslice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"randslice :: Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"_splice"},"_splice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_splice :: Int -> Pattern Int -> ControlPattern -> Pattern (Map String Value) \n")),(0,r.kt)("h3",{id:"splice"},"splice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"splice :: Pattern Int -> Pattern Int -> ControlPattern -> Pattern (Map String Value) \n")),(0,r.kt)("h3",{id:"loopat"},"loopAt"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"loopAt :: Pattern Time -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"loopAt")," makes a sample fit the given number of cycles. Internally, it\nworks by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"unit"),' parameter to "c", changing the playback\nspeed of the sample with the ',(0,r.kt)("inlineCode",{parentName:"p"},"speed")," parameter, and setting setting\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"density")," of the pattern to match."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt 4 $ sound "breaks125"\nd1 $ juxBy 0.6 (|* speed "2") $ slowspread (loopAt) [4,6,2,3] $ chop 12 $ sound "fm:14"\n')),(0,r.kt)("h3",{id:"hurry"},"hurry"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"hurry :: Pattern Rational -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"smash"},"smash"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"smash :: Pattern Int -> [Pattern Time] -> ControlPattern -> Pattern ValueMap \n")),(0,r.kt)("p",null,"Smash is a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"spread")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"striate")," - it cuts the samples\ninto the given number of bits, and then cuts between playing the loop\nat different speeds according to the values in the list."),(0,r.kt)("p",null,"So this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ smash 3 [2,3,4] $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"Is a bit like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ spread (slow) [2,3,4] $ striate 3 $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"This is quite dancehall:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ (spread\' slow "1%4 2 1 3" $ spread (striate) [2,3,4,1] $ sound\n"sn:2 sid:3 cp sid:4")\n  # speed "[1 2 1 1]/2"\n')),(0,r.kt)("h3",{id:"smash-1"},"smash'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"smash' :: Int -> [Pattern Time] -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"an altenative form to ",(0,r.kt)("inlineCode",{parentName:"p"},"smash")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"smash'")," which will use ",(0,r.kt)("inlineCode",{parentName:"p"},"chop")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"striate"),"."),(0,r.kt)("h3",{id:"echo"},"echo"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"echo :: Pattern Integer -> Pattern Rational -> Pattern Double -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"Applies a type of delay to a pattern.\nIt has three parameters, which could be called depth, time and feedback."),(0,r.kt)("p",null,"This adds a bit of echo:\n",(0,r.kt)("inlineCode",{parentName:"p"},'    d1 $ echo 4 0.2 0.5 $ sound "bd sn"\n   ')),(0,r.kt)("p",null,"The above results in 4 echos, each one 50% quieter than the last, with 1/5th of a cycle between them."),(0,r.kt)("p",null,"It is possible to reverse the echo:\n",(0,r.kt)("inlineCode",{parentName:"p"},'    d1 $ echo 4 (-0.2) 0.5 $ sound "bd sn"\n   ')),(0,r.kt)("h3",{id:"_echo"},"_echo"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_echo :: Integer -> Rational -> Double -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"echowith"},"echoWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"echoWith :: Pattern Int -> Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Allows to apply a function for each step and overlays the result delayed by the given time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'   d1 $ echoWith 2 "1%3" (# vowel "{a e i o u}%2") $ sound "bd sn"\n')),(0,r.kt)("p",null,"In this case there are two ",(0,r.kt)("em",{parentName:"p"},"overlays")," delayed by 1/3 of a cycle, where each has the ",(0,r.kt)("inlineCode",{parentName:"p"},"vowel")," filter applied."),(0,r.kt)("h3",{id:"_echowith"},"_echoWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_echoWith :: (Num n, Ord n) => n -> Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"stut"},"stut"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stut :: Pattern Integer -> Pattern Double -> Pattern Rational -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"DEPRECATED, use ",(0,r.kt)("inlineCode",{parentName:"p"},"echo")," instead"),(0,r.kt)("h3",{id:"_stut"},"_stut"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_stut :: Integer -> Double -> Rational -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"stutwith"},"stutWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stutWith :: Pattern Int -> Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"DEPRECATED, use ",(0,r.kt)("inlineCode",{parentName:"p"},"echoWith")," instead"),(0,r.kt)("h3",{id:"_stutwith"},"_stutWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_stutWith :: (Num n, Ord n) => n -> Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"stut-1"},"stut'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stut' :: Pattern Int -> Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"DEPRECATED, use ",(0,r.kt)("inlineCode",{parentName:"p"},"echoWith")," instead"),(0,r.kt)("h3",{id:"sec"},"sec"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sec :: Fractional a => Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Turns a pattern of seconds into a pattern of (rational) cycle durations"),(0,r.kt)("h3",{id:"msec"},"msec"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"msec :: Fractional a => Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Turns a pattern of milliseconds into a pattern of (rational)\ncycle durations, according to the current cps."),(0,r.kt)("h3",{id:"trigger"},"trigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"trigger :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Align the start of a pattern with the time a pattern is evaluated,\nrather than the global start time. Because of this, the pattern will\nprobably not be aligned to the pattern grid."),(0,r.kt)("h3",{id:"qtrigger"},"qtrigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"qtrigger :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"(Alias ",(0,r.kt)("inlineCode",{parentName:"p"},"qt"),") Quantise trigger. Aligns the start of the pattern\nwith the next cycle boundary. For example, this pattern will fade in\nstarting with the next cycle after the pattern is evaluated:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ qtrigger $ s "hh(5, 8)" # amp envL\n')),(0,r.kt)("p",null,"Note that the pattern will start playing immediately. The start of the\npattern aligns with the next cycle boundary, but events will play before\nif the pattern has events at negative timestamps (which most loops do).\nThese events can be filtered out, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ qtrigger $ filterWhen (>= 0) $ s "hh(5, 8)"\n')),(0,r.kt)("h3",{id:"qt"},"qt"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"qt :: Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"ctrigger"},"ctrigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ctrigger :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Ceiling trigger. Aligns the start of a pattern to the next cycle\nboundary, just like ",(0,r.kt)("inlineCode",{parentName:"p"},"qtrigger"),"."),(0,r.kt)("h3",{id:"rtrigger"},"rtrigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rtrigger :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Rounded trigger. Aligns the start of a pattern to the nearest cycle\nboundary, either next or previous."),(0,r.kt)("h3",{id:"ftrigger"},"ftrigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ftrigger :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Floor trigger. Aligns the start of a pattern to the previous cycle\nboundary."),(0,r.kt)("h3",{id:"mtrigger"},"mtrigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mtrigger :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"(Alias ",(0,r.kt)("inlineCode",{parentName:"p"},"mt"),") Mod trigger. Aligns the start of a pattern to the\nnext cycle boundary where the cycle is evenly divisible by a given\nnumber. ",(0,r.kt)("inlineCode",{parentName:"p"},"qtrigger")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"mtrigger 1"),"."),(0,r.kt)("h3",{id:"mt"},"mt"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mt :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"triggerwith"},"triggerWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"triggerWith :: (Time -> Time) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"This aligns the start of a pattern to some value relative to the\ntime the pattern is evaluated. The provided function maps the evaluation\ntime (on the global cycle clock) to a new time, and then ",(0,r.kt)("inlineCode",{parentName:"p"},"triggerWith"),"\naligns the pattern's start to the time that's returned."),(0,r.kt)("h3",{id:"splat"},"splat"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"splat :: Pattern Int -> ControlPattern -> ControlPattern -> ControlPattern \n")))}u.isMDXComponent=!0}}]);