"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4973],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),s=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(o.Provider,{value:t},e.children)},u="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),u=s(a),c=r,m=u["".concat(o,".").concat(c)]||u[c]||k[c]||l;return a?n.createElement(m,i(i({ref:t},d),{},{components:a})):n.createElement(m,i({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=c;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p[u]="string"==typeof e?e:r,i[1]=p;for(var s=2;s<l;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},9141:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var n=a(3117),r=(a(7294),a(3905));const l={title:"Sound.Tidal.UI",slug:"/library/modules/Sound.Tidal.UI"},i=void 0,p={unversionedId:"library/autogenerated/Sound-Tidal-UI/Sound-Tidal-UI",id:"library/autogenerated/Sound-Tidal-UI/Sound-Tidal-UI",title:"Sound.Tidal.UI",description:"\x3c!------------------------------------------------------------------------------",source:"@site/docs/library/autogenerated/Sound-Tidal-UI/Sound-Tidal-UI.mdx",sourceDirName:"library/autogenerated/Sound-Tidal-UI",slug:"/library/modules/Sound.Tidal.UI",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.UI",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/library/autogenerated/Sound-Tidal-UI/Sound-Tidal-UI.mdx",tags:[],version:"current",lastUpdatedBy:"Matthew Kaney",lastUpdatedAt:1673207986,formattedLastUpdatedAt:"Jan 8, 2023",frontMatter:{title:"Sound.Tidal.UI",slug:"/library/modules/Sound.Tidal.UI"},sidebar:"library",previous:{title:"Sound.Tidal.Transition",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Transition"},next:{title:"Sound.Tidal.Utils",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Utils"}},o={},s=[{value:"xorwise",id:"xorwise",level:3},{value:"timeToIntSeed",id:"timetointseed",level:3},{value:"intSeedToRand",id:"intseedtorand",level:3},{value:"timeToRand",id:"timetorand",level:3},{value:"timeToRands",id:"timetorands",level:3},{value:"timeToRands&#39;",id:"timetorands-1",level:3},{value:"rand",id:"rand",level:3},{value:"brand",id:"brand",level:3},{value:"brandBy",id:"brandby",level:3},{value:"_brandBy",id:"_brandby",level:3},{value:"irand",id:"irand",level:3},{value:"_irand",id:"_irand",level:3},{value:"perlinWith",id:"perlinwith",level:3},{value:"perlin",id:"perlin",level:3},{value:"perlin2With",id:"perlin2with",level:3},{value:"perlin2",id:"perlin2",level:3},{value:"choose",id:"choose",level:3},{value:"chooseBy",id:"chooseby",level:3},{value:"wchoose",id:"wchoose",level:3},{value:"wchooseBy",id:"wchooseby",level:3},{value:"degradeBy",id:"degradeby",level:3},{value:"_degradeBy",id:"_degradeby",level:3},{value:"_degradeByUsing",id:"_degradebyusing",level:3},{value:"unDegradeBy",id:"undegradeby",level:3},{value:"_unDegradeBy",id:"_undegradeby",level:3},{value:"degradeOverBy",id:"degradeoverby",level:3},{value:"sometimesBy",id:"sometimesby",level:3},{value:"sometimesBy&#39;",id:"sometimesby-1",level:3},{value:"sometimes",id:"sometimes",level:3},{value:"sometimes&#39;",id:"sometimes-1",level:3},{value:"often",id:"often",level:3},{value:"often&#39;",id:"often-1",level:3},{value:"rarely",id:"rarely",level:3},{value:"rarely&#39;",id:"rarely-1",level:3},{value:"almostNever",id:"almostnever",level:3},{value:"almostNever&#39;",id:"almostnever-1",level:3},{value:"almostAlways",id:"almostalways",level:3},{value:"almostAlways&#39;",id:"almostalways-1",level:3},{value:"never",id:"never",level:3},{value:"always",id:"always",level:3},{value:"someCyclesBy",id:"somecyclesby",level:3},{value:"_someCyclesBy",id:"_somecyclesby",level:3},{value:"somecyclesBy",id:"somecyclesby-1",level:3},{value:"someCycles",id:"somecycles",level:3},{value:"somecycles",id:"somecycles-1",level:3},{value:"degrade",id:"degrade",level:3},{value:"brak",id:"brak",level:3},{value:"iter",id:"iter",level:3},{value:"_iter",id:"_iter",level:3},{value:"iter&#39;",id:"iter-1",level:3},{value:"_iter&#39;",id:"_iter-1",level:3},{value:"palindrome",id:"palindrome",level:3},{value:"seqP",id:"seqp",level:3},{value:"fadeOut",id:"fadeout",level:3},{value:"fadeOutFrom",id:"fadeoutfrom",level:3},{value:"fadeIn",id:"fadein",level:3},{value:"fadeInFrom",id:"fadeinfrom",level:3},{value:"spread",id:"spread",level:3},{value:"slowspread",id:"slowspread",level:3},{value:"fastspread",id:"fastspread",level:3},{value:"spread&#39;",id:"spread-1",level:3},{value:"spreadChoose",id:"spreadchoose",level:3},{value:"spreadr",id:"spreadr",level:3},{value:"ifp",id:"ifp",level:3},{value:"wedge",id:"wedge",level:3},{value:"_wedge",id:"_wedge",level:3},{value:"whenmod",id:"whenmod",level:3},{value:"_whenmod",id:"_whenmod",level:3},{value:"superimpose",id:"superimpose",level:3},{value:"trunc",id:"trunc",level:3},{value:"_trunc",id:"_trunc",level:3},{value:"linger",id:"linger",level:3},{value:"_linger",id:"_linger",level:3},{value:"within",id:"within",level:3},{value:"withinArc",id:"withinarc",level:3},{value:"within&#39;",id:"within-1",level:3},{value:"revArc",id:"revarc",level:3},{value:"euclid",id:"euclid",level:3},{value:"_euclid",id:"_euclid",level:3},{value:"euclidFull",id:"euclidfull",level:3},{value:"_euclidBool",id:"_euclidbool",level:3},{value:"_euclid&#39;",id:"_euclid-1",level:3},{value:"euclidOff",id:"euclidoff",level:3},{value:"eoff",id:"eoff",level:3},{value:"_euclidOff",id:"_euclidoff",level:3},{value:"euclidOffBool",id:"euclidoffbool",level:3},{value:"_euclidOffBool",id:"_euclidoffbool",level:3},{value:"distrib",id:"distrib",level:3},{value:"_distrib",id:"_distrib",level:3},{value:"euclidInv",id:"euclidinv",level:3},{value:"_euclidInv",id:"_euclidinv",level:3},{value:"index",id:"index",level:3},{value:"rot",id:"rot",level:3},{value:"_rot",id:"_rot",level:3},{value:"segment",id:"segment",level:3},{value:"_segment",id:"_segment",level:3},{value:"discretise",id:"discretise",level:3},{value:"randcat",id:"randcat",level:3},{value:"wrandcat",id:"wrandcat",level:3},{value:"_fit",id:"_fit",level:3},{value:"fit",id:"fit",level:3},{value:"permstep",id:"permstep",level:3},{value:"struct",id:"struct",level:3},{value:"substruct",id:"substruct",level:3},{value:"randArcs",id:"randarcs",level:3},{value:"randStruct",id:"randstruct",level:3},{value:"substruct&#39;",id:"substruct-1",level:3},{value:"stripe",id:"stripe",level:3},{value:"_stripe",id:"_stripe",level:3},{value:"slowstripe",id:"slowstripe",level:3},{value:"parseLMRule",id:"parselmrule",level:3},{value:"parseLMRule&#39;",id:"parselmrule-1",level:3},{value:"lindenmayer",id:"lindenmayer",level:3},{value:"lindenmayerI",id:"lindenmayeri",level:3},{value:"runMarkov",id:"runmarkov",level:3},{value:"markovPat",id:"markovpat",level:3},{value:"_markovPat",id:"_markovpat",level:3},{value:"mask",id:"mask",level:3},{value:"enclosingArc",id:"enclosingarc",level:3},{value:"stretch",id:"stretch",level:3},{value:"fit&#39;",id:"fit-1",level:3},{value:"chunk",id:"chunk",level:3},{value:"_chunk",id:"_chunk",level:3},{value:"chunk&#39;",id:"chunk-1",level:3},{value:"_chunk&#39;",id:"_chunk-1",level:3},{value:"_inside",id:"_inside",level:3},{value:"inside",id:"inside",level:3},{value:"_outside",id:"_outside",level:3},{value:"outside",id:"outside",level:3},{value:"loopFirst",id:"loopfirst",level:3},{value:"timeLoop",id:"timeloop",level:3},{value:"seqPLoop",id:"seqploop",level:3},{value:"toScale&#39;",id:"toscale",level:3},{value:"toScale",id:"toscale-1",level:3},{value:"swingBy",id:"swingby",level:3},{value:"swing",id:"swing",level:3},{value:"cycleChoose",id:"cyclechoose",level:3},{value:"_rearrangeWith",id:"_rearrangewith",level:3},{value:"shuffle",id:"shuffle",level:3},{value:"_shuffle",id:"_shuffle",level:3},{value:"scramble",id:"scramble",level:3},{value:"_scramble",id:"_scramble",level:3},{value:"randrun",id:"randrun",level:3},{value:"ur",id:"ur",level:3},{value:"inhabit",id:"inhabit",level:3},{value:"spaceOut",id:"spaceout",level:3},{value:"flatpat",id:"flatpat",level:3},{value:"layer",id:"layer",level:3},{value:"arpeggiate",id:"arpeggiate",level:3},{value:"arpg",id:"arpg",level:3},{value:"arpWith",id:"arpwith",level:3},{value:"arp",id:"arp",level:3},{value:"_arp",id:"_arp",level:3},{value:"rolledWith",id:"rolledwith",level:3},{value:"rolledBy",id:"rolledby",level:3},{value:"rolled",id:"rolled",level:3},{value:"ply",id:"ply",level:3},{value:"_ply",id:"_ply",level:3},{value:"plyWith",id:"plywith",level:3},{value:"_plyWith",id:"_plywith",level:3},{value:"press",id:"press",level:3},{value:"pressBy",id:"pressby",level:3},{value:"_pressBy",id:"_pressby",level:3},{value:"sew",id:"sew",level:3},{value:"stitch",id:"stitch",level:3},{value:"while",id:"while",level:3},{value:"stutter",id:"stutter",level:3},{value:"jux",id:"jux",level:3},{value:"juxcut",id:"juxcut",level:3},{value:"juxcut&#39;",id:"juxcut-1",level:3},{value:"jux&#39;",id:"jux-1",level:3},{value:"jux4",id:"jux4",level:3},{value:"juxBy",id:"juxby",level:3},{value:"pick",id:"pick",level:3},{value:"samples",id:"samples",level:3},{value:"samples&#39;",id:"samples-1",level:3},{value:"spreadf",id:"spreadf",level:3},{value:"stackwith",id:"stackwith",level:3},{value:"range",id:"range",level:3},{value:"_range",id:"_range",level:3},{value:"rangex",id:"rangex",level:3},{value:"off",id:"off",level:3},{value:"_off",id:"_off",level:3},{value:"offadd",id:"offadd",level:3},{value:"step",id:"step",level:3},{value:"steps",id:"steps",level:3},{value:"step&#39;",id:"step-1",level:3},{value:"ghost&#39;&#39;",id:"ghost",level:3},{value:"ghost&#39;",id:"ghost-1",level:3},{value:"ghost",id:"ghost-2",level:3},{value:"tabby",id:"tabby",level:3},{value:"select",id:"select",level:3},{value:"_select",id:"_select",level:3},{value:"selectF",id:"selectf",level:3},{value:"_selectF",id:"_selectf",level:3},{value:"pickF",id:"pickf",level:3},{value:"_pickF",id:"_pickf",level:3},{value:"contrast",id:"contrast",level:3},{value:"contrastBy",id:"contrastby",level:3},{value:"contrastRange",id:"contrastrange",level:3},{value:"fix",id:"fix",level:3},{value:"unfix",id:"unfix",level:3},{value:"fixRange",id:"fixrange",level:3},{value:"unfixRange",id:"unfixrange",level:3},{value:"quantise",id:"quantise",level:3},{value:"qfloor",id:"qfloor",level:3},{value:"qceiling",id:"qceiling",level:3},{value:"qround",id:"qround",level:3},{value:"inv",id:"inv",level:3},{value:"mono",id:"mono",level:3},{value:"smooth",id:"smooth",level:3},{value:"swap",id:"swap",level:3},{value:"snowball",id:"snowball",level:3},{value:"soak",id:"soak",level:3},{value:"deconstruct",id:"deconstruct",level:3},{value:"bite",id:"bite",level:3},{value:"_bite",id:"_bite",level:3},{value:"squeeze",id:"squeeze",level:3},{value:"squeezeJoinUp",id:"squeezejoinup",level:3},{value:"_chew",id:"_chew",level:3},{value:"chew",id:"chew",level:3},{value:"__binary",id:"__binary",level:3},{value:"_binary",id:"_binary",level:3},{value:"_binaryN",id:"_binaryn",level:3},{value:"binaryN",id:"binaryn",level:3},{value:"binary",id:"binary",level:3},{value:"ascii",id:"ascii",level:3},{value:"grain",id:"grain",level:3},{value:"necklace",id:"necklace",level:3}],d={toc:s};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"xorwise"},"xorwise"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"xorwise :: Int -> Int \n")),(0,r.kt)("p",null,"Randomisation"),(0,r.kt)("h3",{id:"timetointseed"},"timeToIntSeed"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"timeToIntSeed :: RealFrac a => a -> Int \n")),(0,r.kt)("h3",{id:"intseedtorand"},"intSeedToRand"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"intSeedToRand :: Fractional a => Int -> a \n")),(0,r.kt)("h3",{id:"timetorand"},"timeToRand"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"timeToRand :: (RealFrac a, Fractional b) => a -> b \n")),(0,r.kt)("h3",{id:"timetorands"},"timeToRands"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"timeToRands :: (RealFrac a, Fractional b) => a -> Int -> [b] \n")),(0,r.kt)("h3",{id:"timetorands-1"},"timeToRands'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"timeToRands' :: Fractional a => Int -> Int -> [a] \n")),(0,r.kt)("h3",{id:"rand"},"rand"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rand :: Fractional a => Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rand")," generates a continuous pattern of (pseudo-)random numbers between ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'sound "bd*8" # pan rand\n')),(0,r.kt)("p",null,"pans bass drums randomly"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'sound "sn sn ~ sn" # gain rand\n')),(0,r.kt)("p",null,"makes the snares' randomly loud and quiet."),(0,r.kt)("p",null,"Numbers coming from this pattern are ",(0,r.kt)("inlineCode",{parentName:"p"},"seeded")," by time. So if you reset\ntime (via ",(0,r.kt)("inlineCode",{parentName:"p"},"cps (-1)"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"cps 1.1")," or whatever cps you want to\nrestart with) the random pattern will emit the exact same ",(0,r.kt)("em",{parentName:"p"},"random"),"\nnumbers again."),(0,r.kt)("p",null,"In cases where you need two different random patterns, you can shift\none of them around to change the time from which the ",(0,r.kt)("em",{parentName:"p"},"random")," pattern\nis read, note the difference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'jux (# gain rand) $ sound "sn sn ~ sn" # gain rand\n')),(0,r.kt)("p",null,"and with the juxed version shifted backwards for 1024 cycles:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'jux (# ((1024 <~) $ gain rand)) $ sound "sn sn ~ sn" # gain rand\n')),(0,r.kt)("h3",{id:"brand"},"brand"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"brand :: Pattern Bool \n")),(0,r.kt)("p",null,"Boolean rand - a continuous stream of truefalse values, with a 5050 chance."),(0,r.kt)("h3",{id:"brandby"},"brandBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"brandBy :: Pattern Double -> Pattern Bool \n")),(0,r.kt)("p",null,"Boolean rand with probability as input, e.g. brandBy 0.25 is 25% chance of being true."),(0,r.kt)("h3",{id:"_brandby"},"_brandBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_brandBy :: Double -> Pattern Bool \n")),(0,r.kt)("h3",{id:"irand"},"irand"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"irand :: Num a => Pattern Int -> Pattern a \n")),(0,r.kt)("p",null,"Just like ",(0,r.kt)("inlineCode",{parentName:"p"},"rand")," but for whole numbers, ",(0,r.kt)("inlineCode",{parentName:"p"},"irand n")," generates a pattern of (pseudo-) random whole numbers between ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"n-1")," inclusive. Notably used to pick a random\nsamples from a folder:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ segment 4 $ n (irand 5) # sound "drum"\n')),(0,r.kt)("h3",{id:"_irand"},"_irand"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_irand :: Num a => Int -> Pattern a \n")),(0,r.kt)("h3",{id:"perlinwith"},"perlinWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"perlinWith :: Fractional a => Pattern Double -> Pattern a \n")),(0,r.kt)("p",null,"1D Perlin (smooth) noise, works like rand but smoothly moves between random\nvalues each cycle. ",(0,r.kt)("inlineCode",{parentName:"p"},"perlinWith"),' takes a pattern as the RNG\'s "input" instead\nof automatically using the cycle count.\n',(0,r.kt)("inlineCode",{parentName:"p"},'d1 $ s "arpy*32" # cutoff (perlinWith (saw * 4) * 2000)'),"\nwill generate a smooth random pattern for the cutoff frequency which will\nrepeat every cycle (because the saw does)\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"perlin")," function uses the cycle count as input and can be used much like ",(0,r.kt)("inlineCode",{parentName:"p"},"rand"),"."),(0,r.kt)("h3",{id:"perlin"},"perlin"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"perlin :: Fractional a => Pattern a \n")),(0,r.kt)("h3",{id:"perlin2with"},"perlin2With"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"perlin2With :: Pattern Double -> Pattern Double -> Pattern Double \n")),(0,r.kt)("h3",{id:"perlin2"},"perlin2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"perlin2 :: Pattern Double -> Pattern Double \n")),(0,r.kt)("h3",{id:"choose"},"choose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"choose :: [a] -> Pattern a \n")),(0,r.kt)("p",null,"Randomly picks an element from the given list"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'sound "superpiano(3,8)" # note (choose ["a", "e", "g", "c"])\n')),(0,r.kt)("p",null,'plays a melody randomly choosing one of the four notes "a", "e", "g", "c".'),(0,r.kt)("h3",{id:"chooseby"},"chooseBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"chooseBy :: Pattern Double -> [a] -> Pattern a \n")),(0,r.kt)("h3",{id:"wchoose"},"wchoose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wchoose :: [(a, Double)] -> Pattern a \n")),(0,r.kt)("p",null,"Like ",(0,r.kt)("inlineCode",{parentName:"p"},"choose"),", but works on an a list of tuples of values and weights"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'sound "superpiano(3,8)" # note (wchoose [("a",1), ("e",0.5), ("g",2), ("c",1)])\n')),(0,r.kt)("p",null,'In the above example, the "a" and "c" notes are twice as likely to\nplay as the "e" note, and half as likely to play as the "g" note.'),(0,r.kt)("h3",{id:"wchooseby"},"wchooseBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wchooseBy :: Pattern Double -> [(a, Double)] -> Pattern a \n")),(0,r.kt)("h3",{id:"degradeby"},"degradeBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"degradeBy :: Pattern Double -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"degrade")," ",(0,r.kt)("inlineCode",{parentName:"p"},"degradeBy")," allows you to control the percentage of events that\nare removed. For example, to remove events 90% of the time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ degradeBy 0.9 $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]"\n   # accelerate "-6"\n   # speed "2"\n')),(0,r.kt)("h3",{id:"_degradeby"},"_degradeBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_degradeBy :: Double -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_degradebyusing"},"_degradeByUsing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_degradeByUsing :: Pattern Double -> Double -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"undegradeby"},"unDegradeBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"unDegradeBy :: Pattern Double -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_undegradeby"},"_unDegradeBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_unDegradeBy :: Double -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"degradeoverby"},"degradeOverBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"degradeOverBy :: Int -> Pattern Double -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"sometimesby"},"sometimesBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sometimesBy :: Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"sometimesBy"),' to apply a given function "sometimes". For example, the\nfollowing code results in ',(0,r.kt)("inlineCode",{parentName:"p"},"density 2")," being applied about 25% of the time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sometimesBy 0.25 (density 2) $ sound "bd*8"\n')),(0,r.kt)("p",null,"There are some aliases as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"sometimes = sometimesBy 0.5\noften = sometimesBy 0.75\nrarely = sometimesBy 0.25\nalmostNever = sometimesBy 0.1\nalmostAlways = sometimesBy 0.9\n")),(0,r.kt)("h3",{id:"sometimesby-1"},"sometimesBy'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sometimesBy' :: Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"sometimes"},"sometimes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sometimes :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sometimes")," is an alias for sometimesBy 0.5."),(0,r.kt)("h3",{id:"sometimes-1"},"sometimes'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sometimes' :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"often"},"often"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"often :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"often")," is an alias for sometimesBy 0.75."),(0,r.kt)("h3",{id:"often-1"},"often'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"often' :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"rarely"},"rarely"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rarely :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rarely")," is an alias for sometimesBy 0.25."),(0,r.kt)("h3",{id:"rarely-1"},"rarely'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rarely' :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"almostnever"},"almostNever"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"almostNever :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"almostNever")," is an alias for sometimesBy 0.1"),(0,r.kt)("h3",{id:"almostnever-1"},"almostNever'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"almostNever' :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"almostalways"},"almostAlways"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"almostAlways :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"almostAlways")," is an alias for sometimesBy 0.9"),(0,r.kt)("h3",{id:"almostalways-1"},"almostAlways'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"almostAlways' :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"never"},"never"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"never :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"always"},"always"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"always :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"somecyclesby"},"someCyclesBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"someCyclesBy :: Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"someCyclesBy")," is a cycle-by-cycle version of ",(0,r.kt)("inlineCode",{parentName:"p"},"sometimesBy"),". It has a\n",(0,r.kt)("inlineCode",{parentName:"p"},"someCycles = someCyclesBy 0.5")," alias "),(0,r.kt)("h3",{id:"_somecyclesby"},"_someCyclesBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_someCyclesBy :: Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"somecyclesby-1"},"somecyclesBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"somecyclesBy :: Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"somecycles"},"someCycles"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"someCycles :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"somecycles-1"},"somecycles"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"somecycles :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"degrade"},"degrade"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"degrade :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"degrade")," randomly removes events from a pattern 50% of the time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ degrade $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]"\n   # accelerate "-6"\n   # speed "2"\n')),(0,r.kt)("p",null,"The shorthand syntax for ",(0,r.kt)("inlineCode",{parentName:"p"},"degrade")," is a question mark: ",(0,r.kt)("inlineCode",{parentName:"p"},"?"),". Using ",(0,r.kt)("inlineCode",{parentName:"p"},"?"),"\nwill allow you to randomly remove events from a portion of a pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ sound "bd ~ sn bd ~ bd? [sn bd?] ~"\n')),(0,r.kt)("p",null,"You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," to randomly remove events from entire sub-patterns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ sound "[[[feel:5*8,feel*3] feel:3*8]?, feel*4]"\n')),(0,r.kt)("h3",{id:"brak"},"brak"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"brak :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"(The above means that ",(0,r.kt)("inlineCode",{parentName:"p"},"brak")," is a function from patterns of any type,\nto a pattern of the same type.)"),(0,r.kt)("p",null,"Make a pattern sound a bit like a breakbeat"),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound (brak "bd sn kurt")\n')),(0,r.kt)("h3",{id:"iter"},"iter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"iter :: Pattern Int -> Pattern c -> Pattern c \n")),(0,r.kt)("p",null,"Divides a pattern into a given number of subdivisions, plays the subdivisions\nin order, but increments the starting subdivision each cycle. The pattern\nwraps to the first subdivision after the last subdivision is played."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ iter 4 $ sound "bd hh sn cp"\n')),(0,r.kt)("p",null,"This will produce the following over four cycles:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"bd hh sn cp\nhh sn cp bd\nsn cp bd hh\ncp bd hh sn\n")),(0,r.kt)("p",null,"There is also ",(0,r.kt)("inlineCode",{parentName:"p"},"iter'"),", which shifts the pattern in the opposite direction."),(0,r.kt)("h3",{id:"_iter"},"_iter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_iter :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"iter-1"},"iter'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"iter' :: Pattern Int -> Pattern c -> Pattern c \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"iter'")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"iter"),", but decrements the starting\nsubdivision instead of incrementing it."),(0,r.kt)("h3",{id:"_iter-1"},"_iter'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_iter' :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"palindrome"},"palindrome"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"palindrome :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"palindrome p")," applies ",(0,r.kt)("inlineCode",{parentName:"p"},"rev")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," every other cycle, so that\nthe pattern alternates between forwards and backwards."),(0,r.kt)("h3",{id:"seqp"},"seqP"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"seqP :: [(Time, Time, Pattern a)] -> Pattern a \n")),(0,r.kt)("p",null,"Composing patterns"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"seqP")," allows you to define when\na sound within a list starts and ends. The code below contains three\nseparate patterns in a ",(0,r.kt)("inlineCode",{parentName:"p"},"stack"),", but each has different start times\n(zero cycles, eight cycles, and sixteen cycles, respectively). All\npatterns stop after 128 cycles:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ seqP [\n  (0, 128, sound "bd bd*2"),\n  (8, 128, sound "hh*2 [sn cp] cp future*4"),\n  (16, 128, sound (samples "arpy*8" (run 16)))\n]\n')),(0,r.kt)("h3",{id:"fadeout"},"fadeOut"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fadeOut :: Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Degrades a pattern over the given time."),(0,r.kt)("h3",{id:"fadeoutfrom"},"fadeOutFrom"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fadeOutFrom :: Time -> Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Alternate version to ",(0,r.kt)("inlineCode",{parentName:"p"},"fadeOut")," where you can provide the time from which the fade starts"),(0,r.kt)("h3",{id:"fadein"},"fadeIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fadeIn :: Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Undegrades")," a pattern over the given time."),(0,r.kt)("h3",{id:"fadeinfrom"},"fadeInFrom"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fadeInFrom :: Time -> Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Alternate version to ",(0,r.kt)("inlineCode",{parentName:"p"},"fadeIn")," where you can provide the time from\nwhich the fade in starts"),(0,r.kt)("h3",{id:"spread"},"spread"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b \n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"spread")," function allows you to take a pattern transformation\nwhich takes a parameter, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"slow"),", and provide several\nparameters which are switched between. In other words it ",(0,r.kt)("inlineCode",{parentName:"p"},"spreads")," a\nfunction across several values."),(0,r.kt)("p",null,"Taking a simple high hat loop as an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"We can slow it down by different amounts, such as by a half:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"Or by four thirds (i.e. speeding it up by a third; ",(0,r.kt)("inlineCode",{parentName:"p"},"4%3")," means four over\nthree):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow (4%3) $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"But if we use ",(0,r.kt)("inlineCode",{parentName:"p"},"spread"),", we can make a pattern which alternates between\nthe two speeds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ spread slow [2,4%3] $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"Note that if you pass ($) as the function to spread values over, you\ncan put functions as the list of values. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ spread ($) [density 2, rev, slow 2, striate 3, (# speed "0.8")]\n    $ sound "[bd*2 [~ bd]] [sn future]*2 cp jvbass*4"\n')),(0,r.kt)("p",null,"Above, the pattern will have these transforms applied to it, one at a time, per cycle:"),(0,r.kt)("p",null,"After ",(0,r.kt)("inlineCode",{parentName:"p"},'(# speed "0.8")'),", the transforms will repeat and start at ",(0,r.kt)("inlineCode",{parentName:"p"},"density 2")," again."),(0,r.kt)("h3",{id:"slowspread"},"slowspread"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"slowspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b \n")),(0,r.kt)("h3",{id:"fastspread"},"fastspread"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fastspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"fastspread")," works the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"spread"),", but the result is squashed into a single cycle. If you gave four values to ",(0,r.kt)("inlineCode",{parentName:"p"},"spread"),", then the result would seem to speed up by a factor of four. Compare these two:"),(0,r.kt)("p",null,"d1 $ spread chop ","[4,64,32,16]",' $ sound "ho ho:2 ho:3 hc"'),(0,r.kt)("p",null,"d1 $ fastspread chop ","[4,64,32,16]",' $ sound "ho ho:2 ho:3 hc"'),(0,r.kt)("p",null,"There is also ",(0,r.kt)("inlineCode",{parentName:"p"},"slowspread"),", which is an alias of ",(0,r.kt)("inlineCode",{parentName:"p"},"spread"),"."),(0,r.kt)("h3",{id:"spread-1"},"spread'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spread' :: Monad m => (a -> b -> m c) -> m a -> b -> m c \n")),(0,r.kt)("p",null,"There's a version of this function, ",(0,r.kt)("inlineCode",{parentName:"p"},"spread'"),' (pronounced "spread prime"), which takes a ',(0,r.kt)("em",{parentName:"p"},"pattern")," of parameters, instead of a list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ spread\' slow "2 4%3" $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("p",null,"This is quite a messy area of Tidal - due to a slight difference of\nimplementation this sounds completely different! One advantage of\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"spread'")," though is that you can provide polyphonic parameters, e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ spread\' slow "[2 4%3, 3]" $ sound "ho ho:2 ho:3 hc"\n')),(0,r.kt)("h3",{id:"spreadchoose"},"spreadChoose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spreadChoose :: (t -> t1 -> Pattern b) -> [t] -> t1 -> Pattern b \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spreadChoose f xs p")," is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"slowspread")," but picks values from\n",(0,r.kt)("inlineCode",{parentName:"p"},"xs")," at random, rather than cycling through them in order. It has a\nshorter alias ",(0,r.kt)("inlineCode",{parentName:"p"},"spreadr"),"."),(0,r.kt)("h3",{id:"spreadr"},"spreadr"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spreadr :: (t -> t1 -> Pattern b) -> [t] -> t1 -> Pattern b \n")),(0,r.kt)("h3",{id:"ifp"},"ifp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ifp :: (Int -> Bool) -> (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Decide whether to apply one or another function depending on the result of a test function that is passed the current cycle as a number."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ ifp ((== 0).(flip mod 2))\n  (striate 4)\n  (# coarse "24 48") $\n  sound "hh hc"\n')),(0,r.kt)("p",null,"This will apply ",(0,r.kt)("inlineCode",{parentName:"p"},"striate 4")," for every ",(0,r.kt)("em",{parentName:"p"},"even")," cycle and aply ",(0,r.kt)("inlineCode",{parentName:"p"},'# coarse "24 48"')," for every ",(0,r.kt)("em",{parentName:"p"},"odd"),"."),(0,r.kt)("p",null,"Detail: As you can see the test function is arbitrary and does not rely on anything tidal specific. In fact it uses only plain haskell functionality, that is: it calculates the modulo of 2 of the current cycle which is either 0 (for even cycles) or 1. It then compares this value against 0 and returns the result, which is either ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),". This is what the ",(0,r.kt)("inlineCode",{parentName:"p"},"ifp")," signature's first part signifies ",(0,r.kt)("inlineCode",{parentName:"p"},"(Int -> Bool)"),", a function that takes a whole number and returns either ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,r.kt)("h3",{id:"wedge"},"wedge"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wedge :: Pattern Time -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"wedge t p p'")," combines patterns ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"p'")," by squashing the\n",(0,r.kt)("inlineCode",{parentName:"p"},"p")," into the portion of each cycle given by ",(0,r.kt)("inlineCode",{parentName:"p"},"t"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"p'")," into the\nremainer of each cycle."),(0,r.kt)("h3",{id:"_wedge"},"_wedge"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_wedge :: Time -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"whenmod"},"whenmod"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"whenmod :: Pattern Time -> Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"whenmod")," has a similar form and behavior to ",(0,r.kt)("inlineCode",{parentName:"p"},"every"),", but requires an\nadditional number. Applies the function to the pattern, when the\nremainder of the current loop number divided by the first parameter,\nis greater or equal than the second parameter."),(0,r.kt)("p",null,"For example the following makes every other block of four loops twice\nas dense:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ whenmod 8 4 (density 2) (sound "bd sn kurt")\n')),(0,r.kt)("h3",{id:"_whenmod"},"_whenmod"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_whenmod :: Time -> Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"superimpose"},"superimpose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"superimpose :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"superimpose f p = stack [p, f p]\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"superimpose")," plays a modified version of a pattern at the same time as the original pattern,\nresulting in two patterns being played at the same time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ superimpose (density 2) $ sound "bd sn [cp ht] hh"\nd1 $ superimpose ((# speed "2") . (0.125 <~)) $ sound "bd sn cp hh"\n')),(0,r.kt)("h3",{id:"trunc"},"trunc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"trunc :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"trunc")," truncates a pattern so that only a fraction of the pattern is played.\nThe following example plays only the first quarter of the pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ trunc 0.25 $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2"\n')),(0,r.kt)("h3",{id:"_trunc"},"_trunc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_trunc :: Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"linger"},"linger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"linger :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"linger")," is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"trunc")," but the truncated part of the pattern loops until the end of the cycle."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ linger 0.25 $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2"\n')),(0,r.kt)("p",null,"If you give it a negative number, it will linger on the last part of\nthe pattern, instead of the start of it. E.g. to linger on the last\nquarter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ linger (-0.25) $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2"\n')),(0,r.kt)("h3",{id:"_linger"},"_linger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_linger :: Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"within"},"within"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"within :: (Time, Time) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"within")," to apply a function to only a part of a pattern. For example, to\napply ",(0,r.kt)("inlineCode",{parentName:"p"},"density 2")," to only the first half of a pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ within (0, 0.5) (density 2) $ sound "bd*2 sn lt mt hh hh hh hh"\n')),(0,r.kt)("p",null,'Or, to apply `(# speed "0.5") to only the last quarter of a pattern:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ within (0.75, 1) (# speed "0.5") $ sound "bd*2 sn lt mt hh hh hh hh"\n')),(0,r.kt)("h3",{id:"withinarc"},"withinArc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"withinArc :: Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"within-1"},"within'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"within' :: (Time, Time) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"For many cases, ",(0,r.kt)("inlineCode",{parentName:"p"},"within'")," will function exactly as within.\nThe difference between the two occurs when applying functions that change the timing of notes such as ",(0,r.kt)("inlineCode",{parentName:"p"},"fast")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"<~"),'.\nwithin first applies the function to all notes in the cycle, then keeps the results in the specified interval, and then combines it with the old cycle (an "apply split combine" paradigm).\nwithin\' first keeps notes in the specified interval, then applies the function to these notes, and then combines it with the old cycle (a "split apply combine" paradigm).'),(0,r.kt)("p",null,"For example, whereas using the standard version of within"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ within (0, 0.25) (fast 2) $ sound "bd hh cp sd"\n')),(0,r.kt)("p",null,"sounds like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[bd hh] hh cp sd"\n')),(0,r.kt)("p",null,"using this alternative version, within'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ within\' (0, 0.25) (fast 2) $ sound "bd hh cp sd"\n')),(0,r.kt)("p",null,"sounds like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[bd bd] hh cp sd"\n')),(0,r.kt)("h3",{id:"revarc"},"revArc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"revArc :: (Time, Time) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"euclid"},"euclid"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"euclid :: Pattern Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," function to apply a Euclidean algorithm over a\ncomplex pattern, although the structure of that pattern will be lost:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ e 3 8 $ sound "bd*2 [sn cp]"\n')),(0,r.kt)("p",null,"In the above, three sounds are picked from the pattern on the right according\nto the structure given by the ",(0,r.kt)("inlineCode",{parentName:"p"},"e 3 8"),". It ends up picking two ",(0,r.kt)("inlineCode",{parentName:"p"},"bd")," sounds, a\n",(0,r.kt)("inlineCode",{parentName:"p"},"cp")," and missing the ",(0,r.kt)("inlineCode",{parentName:"p"},"sn")," entirely."),(0,r.kt)("p",null,"A negative first argument provides the inverse of the euclidean pattern."),(0,r.kt)("p",null,"These types of sequences use \"Bjorklund's algorithm\", which wasn't made for\nmusic but for an application in nuclear physics, which is exciting. More\nexciting still is that it is very similar in structure to the one of the first\nknown algorithms written in Euclid's book of elements in 300 BC. You can read\nmore about this in the paper\nThe Euclidean Algorithm Generates Traditional Musical Rhythms\nby Toussaint. Some examples from this paper are included below,\nincluding rotation in some cases."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"- (2,5) : A thirteenth century Persian rhythm called Khafif-e-ramal.\n- (3,4) : The archetypal pattern of the Cumbia from Colombia, as well as a Calypso rhythm from Trinidad.\n- (3,5,2) : Another thirteenth century Persian rhythm by the name of Khafif-e-ramal, as well as a Rumanian folk-dance rhythm.\n- (3,7) : A Ruchenitza rhythm used in a Bulgarian folk-dance.\n- (3,8) : The Cuban tresillo pattern.\n- (4,7) : Another Ruchenitza Bulgarian folk-dance rhythm.\n- (4,9) : The Aksak rhythm of Turkey.\n- (4,11) : The metric pattern used by Frank Zappa in his piece titled Outside Now.\n- (5,6) : Yields the York-Samai pattern, a popular Arab rhythm.\n- (5,7) : The Nawakhat pattern, another popular Arab rhythm.\n- (5,8) : The Cuban cinquillo pattern.\n- (5,9) : A popular Arab rhythm called Agsag-Samai.\n- (5,11) : The metric pattern used by Moussorgsky in Pictures at an Exhibition.\n- (5,12) : The Venda clapping pattern of a South African children\u2019s song.\n- (5,16) : The Bossa-Nova rhythm necklace of Brazil.\n- (7,8) : A typical rhythm played on the Bendir (frame drum).\n- (7,12) : A common West African bell pattern.\n- (7,16,14) : A Samba rhythm necklace from Brazil.\n- (9,16) : A rhythm necklace used in the Central African Republic.\n- (11,24,14) : A rhythm necklace of the Aka Pygmies of Central Africa.\n- (13,24,5) : Another rhythm necklace of the Aka Pygmies of the upper Sangha.\n")),(0,r.kt)("h3",{id:"_euclid"},"_euclid"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_euclid :: Int -> Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"euclidfull"},"euclidFull"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"euclidFull :: Pattern Int -> Pattern Int -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"euclidfull n k pa pb")," stacks ",(0,r.kt)("inlineCode",{parentName:"p"},"e n k pa")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"einv n k pb")," "),(0,r.kt)("h3",{id:"_euclidbool"},"_euclidBool"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_euclidBool :: Int -> Int -> Pattern Bool \n")),(0,r.kt)("h3",{id:"_euclid-1"},"_euclid'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_euclid' :: Int -> Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"euclidoff"},"euclidOff"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"euclidOff :: Pattern Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"eoff"},"eoff"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"eoff :: Pattern Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_euclidoff"},"_euclidOff"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_euclidOff :: Int -> Int -> Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"euclidoffbool"},"euclidOffBool"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"euclidOffBool :: Pattern Int -> Pattern Int -> Pattern Int -> Pattern Bool -> Pattern Bool \n")),(0,r.kt)("h3",{id:"_euclidoffbool"},"_euclidOffBool"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_euclidOffBool :: Int -> Int -> Int -> Pattern Bool -> Pattern Bool \n")),(0,r.kt)("h3",{id:"distrib"},"distrib"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"distrib :: [Pattern Int] -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_distrib"},"_distrib"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_distrib :: [Int] -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"euclidinv"},"euclidInv"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"euclidInv :: Pattern Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"euclidInv")," fills in the blanks left by ",(0,r.kt)("inlineCode",{parentName:"p"},"e")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'e 3 8 "x"')," -> ",(0,r.kt)("inlineCode",{parentName:"li"},'"x ~ ~ x ~ ~ x ~"'))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'euclidInv 3 8 "x"')," -> ",(0,r.kt)("inlineCode",{parentName:"p"},'"~ x x ~ x x ~ x"')),(0,r.kt)("h3",{id:"_euclidinv"},"_euclidInv"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_euclidInv :: Int -> Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"index"},"index"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"index :: Real b => b -> Pattern b -> Pattern c -> Pattern c \n")),(0,r.kt)("h3",{id:"rot"},"rot"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rot :: Ord a => Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rot n p")," rotates the values in a pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," by ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," beats to the left.\nExample: ",(0,r.kt)("inlineCode",{parentName:"p"},'d1 $ every 4 (rot 2) $ slow 2 $ sound "bd hh hh hh"')),(0,r.kt)("h3",{id:"_rot"},"_rot"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_rot :: Ord a => Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"segment"},"segment"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"segment :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"segment n p"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"samples")," the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," at a rate of ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"\nevents per cycle. Useful for turning a continuous pattern into a\ndiscrete one."),(0,r.kt)("h3",{id:"_segment"},"_segment"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_segment :: Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"discretise"},"discretise"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"discretise :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"discretise"),": the old (deprecated) name for ",(0,r.kt)("inlineCode",{parentName:"p"},"segment")),(0,r.kt)("h3",{id:"randcat"},"randcat"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"randcat :: [Pattern a] -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"randcat ps"),": does a ",(0,r.kt)("inlineCode",{parentName:"p"},"slowcat")," on the list of patterns ",(0,r.kt)("inlineCode",{parentName:"p"},"ps")," but\nrandomises the order in which they are played."),(0,r.kt)("h3",{id:"wrandcat"},"wrandcat"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wrandcat :: [(Pattern a, Double)] -> Pattern a \n")),(0,r.kt)("h3",{id:"_fit"},"_fit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_fit :: Int -> [a] -> Pattern Int -> Pattern a \n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"fit")," function takes a pattern of integer numbers, which are used to select values from the given list. What makes this a bit strange is that only a given number of values are selected each cycle. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound (fit 3 ["bd", "sn", "arpy", "arpy:1", "casio"] "0 [~ 1] 2 1")\n')),(0,r.kt)("p",null,"The above fits three samples into the pattern, i.e. for the first cycle this will be ",(0,r.kt)("inlineCode",{parentName:"p"},'"bd"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"sn"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'"arpy"'),", giving the result ",(0,r.kt)("inlineCode",{parentName:"p"},'"bd [~ sn] arpy sn"')," (note that we start counting at zero, so that ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," picks the first value). The following cycle the ",(0,r.kt)("em",{parentName:"p"},"next")," three values in the list will be picked, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},'"arpy:1"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"casio"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'"bd"'),", giving the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},'"arpy:1 [~ casio] bd casio"')," (note that the list wraps round here)."),(0,r.kt)("h3",{id:"fit"},"fit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fit :: Pattern Int -> [a] -> Pattern Int -> Pattern a \n")),(0,r.kt)("h3",{id:"permstep"},"permstep"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"permstep :: RealFrac b => Int -> [a] -> Pattern b -> Pattern a \n")),(0,r.kt)("h3",{id:"struct"},"struct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"struct :: Pattern Bool -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"struct a b"),": structures pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," in terms of the pattern of\nboolean values ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". Only ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," values in the boolean pattern are\nused."),(0,r.kt)("h3",{id:"substruct"},"substruct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"substruct :: Pattern Bool -> Pattern b -> Pattern b \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"substruct a b"),": similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),", but each event in pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," gets replaced with pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),", compressed to fit the timespan of the event."),(0,r.kt)("h3",{id:"randarcs"},"randArcs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"randArcs :: Int -> Pattern [Arc] \n")),(0,r.kt)("h3",{id:"randstruct"},"randStruct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"randStruct :: Int -> Pattern Int \n")),(0,r.kt)("h3",{id:"substruct-1"},"substruct'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"substruct' :: Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"stripe"},"stripe"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stripe :: Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"stripe n p"),": repeats pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," times per cycle. So\nsimilar to ",(0,r.kt)("inlineCode",{parentName:"p"},"fast"),", but with random durations. The repetitions will\nbe continguous (touching, but not overlapping) and the durations\nwill add up to a single cycle. ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," can be supplied as a pattern of\nintegers."),(0,r.kt)("h3",{id:"_stripe"},"_stripe"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_stripe :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"slowstripe"},"slowstripe"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"slowstripe :: Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"slowstripe n p"),": The same as ",(0,r.kt)("inlineCode",{parentName:"p"},"stripe"),", but the result is also\n",(0,r.kt)("inlineCode",{parentName:"p"},"n")," times slower, so that the mean average duration of the stripes\nis exactly one cycle, and every ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"th stripe starts on a cycle\nboundary (in indian classical terms, the ",(0,r.kt)("inlineCode",{parentName:"p"},"sam"),")."),(0,r.kt)("h3",{id:"parselmrule"},"parseLMRule"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"parseLMRule :: String -> [(String, String)] \n")),(0,r.kt)("h3",{id:"parselmrule-1"},"parseLMRule'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"parseLMRule' :: String -> [(Char, String)] \n")),(0,r.kt)("h3",{id:"lindenmayer"},"lindenmayer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"lindenmayer :: Int -> String -> String -> String \n")),(0,r.kt)("p",null,"returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"th iteration of a Lindenmayer System with given start sequence."),(0,r.kt)("p",null,"for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'lindenmayer 1 "a:b,b:ab" "ab" -> "bab"\n')),(0,r.kt)("h3",{id:"lindenmayeri"},"lindenmayerI"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"lindenmayerI :: Num b => Int -> String -> String -> [b] \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"lindenmayerI")," converts the resulting string into a a list of integers\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"fromIntegral")," applied (so they can be used seamlessly where floats or\nrationals are required) "),(0,r.kt)("h3",{id:"runmarkov"},"runMarkov"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"runMarkov :: Int -> [[Double]] -> Int -> Time -> [Int] \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"runMarkov n tmat xi seed")," generates a Markov chain (as a list) of length ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"\nusing the transition matrix ",(0,r.kt)("inlineCode",{parentName:"p"},"tmat")," starting from initial state ",(0,r.kt)("inlineCode",{parentName:"p"},"xi"),", starting\nwith random numbers generated from ",(0,r.kt)("inlineCode",{parentName:"p"},"seed"),"\nEach entry in the chain is the index of state (starting from zero).\nEach row of the matrix will be automatically normalized. For example:\n",(0,r.kt)("inlineCode",{parentName:"p"},"runMarkov 8 [[2,3], [1,3]] 0 0"),"\nwill produce a two-state chain 8 steps long, from initial state ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", where the\ntransition probability from state 0->0 is 25, 0->1 is 35, 1->0 is 1/4, and\n1->1 is 3/4.  "),(0,r.kt)("h3",{id:"markovpat"},"markovPat"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"markovPat :: Pattern Int -> Pattern Int -> [[Double]] -> Pattern Int \n")),(0,r.kt)("h3",{id:"_markovpat"},"_markovPat"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_markovPat :: Int -> Int -> [[Double]] -> Pattern Int \n")),(0,r.kt)("h3",{id:"mask"},"mask"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mask :: Pattern Bool -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Removes events from second pattern that don't start during an event from first."),(0,r.kt)("p",null,"Consider this, kind of messy rhythm without any rests."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound (slowcat ["sn*8", "[cp*4 bd*4, hc*5]"]) # n (run 8)\n')),(0,r.kt)("p",null,"If we apply a mask to it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ s (mask ("1 1 1 ~ 1 1 ~ 1" :: Pattern Bool)\n  (slowcat ["sn*8", "[cp*4 bd*4, bass*5]"] ))\n  # n (run 8)\n')),(0,r.kt)("p",null,"Due to the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"slowcat")," here, the same mask is first applied to ",(0,r.kt)("inlineCode",{parentName:"p"},'"sn*8"'),' and in the next cycle to `"',"[cp",(0,r.kt)("em",{parentName:"p"},"4 bd"),"4, hc*5]",'".'),(0,r.kt)("p",null,"You could achieve the same effect by adding rests within the ",(0,r.kt)("inlineCode",{parentName:"p"},"slowcat")," patterns, but mask allows you to do this more easily. It kind of keeps the rhythmic structure and you can change the used samples independently, e.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ s (mask ("1 ~ 1 ~ 1 1 ~ 1")\n  (slowcat ["can*8", "[cp*4 sn*4, jvbass*16]"] ))\n  # n (run 8)\n')),(0,r.kt)("h3",{id:"enclosingarc"},"enclosingArc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"enclosingArc :: [Arc] -> Arc \n")),(0,r.kt)("p",null,"TODO: refactor towards union"),(0,r.kt)("h3",{id:"stretch"},"stretch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stretch :: Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"fit-1"},"fit'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fit' :: Pattern Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"fit'")," is a generalization of ",(0,r.kt)("inlineCode",{parentName:"p"},"fit"),", where the list is instead constructed by using another integer pattern to slice up a given pattern.  The first argument is the number of cycles of that latter pattern to use when slicing.  It's easier to understand this with a few examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound (fit\' 1 2 "0 1" "1 0" "bd sn")\n')),(0,r.kt)("p",null,"So what does this do?  The first ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," just tells it to slice up a single cycle of ",(0,r.kt)("inlineCode",{parentName:"p"},'"bd sn"'),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," tells it to select two values each cycle, just like the first argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"fit"),".  The next pattern ",(0,r.kt)("inlineCode",{parentName:"p"},'"0 1"'),' is the "from" pattern which tells it how to slice, which in this case means ',(0,r.kt)("inlineCode",{parentName:"p"},'"0"')," maps to ",(0,r.kt)("inlineCode",{parentName:"p"},'"bd"'),", and ",(0,r.kt)("inlineCode",{parentName:"p"},'"1"')," maps to ",(0,r.kt)("inlineCode",{parentName:"p"},'"sn"'),".  The next pattern ",(0,r.kt)("inlineCode",{parentName:"p"},'"1 0"'),' is the "to" pattern, which tells it how to rearrange those slices.  So the final result is the pattern ',(0,r.kt)("inlineCode",{parentName:"p"},'"sn bd"'),"."),(0,r.kt)("p",null,"A more useful example might be something like"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ fit\' 1 4 (run 4) "[0 3*2 2 1 0 3*2 2 [1*8 ~]]/2" $ chop 4 $ (sound "breaks152" # unit "c")\n')),(0,r.kt)("p",null,"which uses ",(0,r.kt)("inlineCode",{parentName:"p"},"chop")," to break a single sample into individual pieces, which ",(0,r.kt)("inlineCode",{parentName:"p"},"fit'")," then puts into a list (using the ",(0,r.kt)("inlineCode",{parentName:"p"},"run 4")," pattern) and reassembles according to the complicated integer pattern."),(0,r.kt)("h3",{id:"chunk"},"chunk"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"chunk :: Pattern Int -> (Pattern b -> Pattern b) -> Pattern b -> Pattern b \n")),(0,r.kt)("p",null,"Treats the given pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," as having ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," chunks, and applies the function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," to one of those sections per cycle.\nRunning:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"from left to right if chunk number is positive"),(0,r.kt)("li",{parentName:"ul"},"from right to left if chunk number is negative")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},' d1 $ chunk 4 (fast 4) $ sound "cp sn arpy [mt lt]"\n')),(0,r.kt)("h3",{id:"_chunk"},"_chunk"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_chunk :: Integral a => a -> (Pattern b -> Pattern b) -> Pattern b -> Pattern b \n")),(0,r.kt)("h3",{id:"chunk-1"},"chunk'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"chunk' :: Integral a1 => Pattern a1 -> (Pattern a2 -> Pattern a2) -> Pattern a2 -> Pattern a2 \n")),(0,r.kt)("p",null,"DEPRECATED, use ",(0,r.kt)("inlineCode",{parentName:"p"},"chunk")," with negative numbers instead"),(0,r.kt)("h3",{id:"_chunk-1"},"_chunk'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_chunk' :: Integral a => a -> (Pattern b -> Pattern b) -> Pattern b -> Pattern b \n")),(0,r.kt)("p",null,"DEPRECATED, use ",(0,r.kt)("inlineCode",{parentName:"p"},"_chunk")," with negative numbers instead"),(0,r.kt)("h3",{id:"_inside"},"_inside"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_inside :: Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a \n")),(0,r.kt)("h3",{id:"inside"},"inside"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"inside :: Pattern Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a \n")),(0,r.kt)("h3",{id:"_outside"},"_outside"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_outside :: Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a \n")),(0,r.kt)("h3",{id:"outside"},"outside"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"outside :: Pattern Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a \n")),(0,r.kt)("h3",{id:"loopfirst"},"loopFirst"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"loopFirst :: Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"timeloop"},"timeLoop"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"timeLoop :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"seqploop"},"seqPLoop"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"seqPLoop :: [(Time, Time, Pattern a)] -> Pattern a \n")),(0,r.kt)("h3",{id:"toscale"},"toScale'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"toScale' :: Num a => Int -> [a] -> Pattern Int -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toScale")," lets you turn a pattern of notes within a scale (expressed as a\nlist) to note numbers.  For example ",(0,r.kt)("inlineCode",{parentName:"p"},'toScale [0, 4, 7] "0 1 2 3"')," will turn\ninto the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},'"0 4 7 12"'),".  It assumes your scale fits within an octave;\nto change this use ",(0,r.kt)("inlineCode",{parentName:"p"},"toScale")," size",(0,r.kt)("inlineCode",{parentName:"p"},".  Example:\n"),"toScale",(0,r.kt)("inlineCode",{parentName:"p"}," 24 [0,4,7,10,14,17] (run 8)")," turns into ",(0,r.kt)("inlineCode",{parentName:"p"},'"0 4 7 10 14 17 24 28"')),(0,r.kt)("h3",{id:"toscale-1"},"toScale"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"toScale :: Num a => [a] -> Pattern Int -> Pattern a \n")),(0,r.kt)("h3",{id:"swingby"},"swingBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"swingBy :: Pattern Time -> Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"swingBy x n")," divides a cycle into ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," slices and delays the notes in\nthe second half of each slice by ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," fraction of a slice . ",(0,r.kt)("inlineCode",{parentName:"p"},"swing")," is an alias\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"swingBy (1%3)")),(0,r.kt)("h3",{id:"swing"},"swing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"swing :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"cyclechoose"},"cycleChoose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cycleChoose :: [a] -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cycleChoose")," is like ",(0,r.kt)("inlineCode",{parentName:"p"},"choose")," but only picks a new item from the list\nonce each cycle "),(0,r.kt)("h3",{id:"_rearrangewith"},"_rearrangeWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_rearrangeWith :: Pattern Int -> Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Internal function used by shuffle and scramble "),(0,r.kt)("h3",{id:"shuffle"},"shuffle"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"shuffle :: Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"shuffle n p")," evenly divides one cycle of the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," parts,\nand returns a random permutation of the parts each cycle.  For example,\n",(0,r.kt)("inlineCode",{parentName:"p"},'shuffle 3 "a b c"')," could return ",(0,r.kt)("inlineCode",{parentName:"p"},'"a b c"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"a c b"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"b a c"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"b c a"'),",\n",(0,r.kt)("inlineCode",{parentName:"p"},'"c a b"'),", or ",(0,r.kt)("inlineCode",{parentName:"p"},'"c b a"'),".  But it will ",(0,r.kt)("strong",{parentName:"p"},"never")," return ",(0,r.kt)("inlineCode",{parentName:"p"},'"a a a"'),", because that\nis not a permutation of the parts."),(0,r.kt)("h3",{id:"_shuffle"},"_shuffle"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_shuffle :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"scramble"},"scramble"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"scramble :: Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"scramble n p")," is like ",(0,r.kt)("inlineCode",{parentName:"p"},"shuffle")," but randomly selects from the parts\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," instead of making permutations.\nFor example, ",(0,r.kt)("inlineCode",{parentName:"p"},'scramble 3 "a b c"')," will randomly select 3 parts from\n",(0,r.kt)("inlineCode",{parentName:"p"},'"a"')," ",(0,r.kt)("inlineCode",{parentName:"p"},'"b"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'"c"'),", possibly repeating a single part."),(0,r.kt)("h3",{id:"_scramble"},"_scramble"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_scramble :: Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"randrun"},"randrun"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"randrun :: Int -> Pattern Int \n")),(0,r.kt)("h3",{id:"ur"},"ur"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ur :: Time -> Pattern String -> [(String, Pattern a)] -> [(String, Pattern a -> Pattern a)] -> Pattern a \n")),(0,r.kt)("h3",{id:"inhabit"},"inhabit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"inhabit :: [(String, Pattern a)] -> Pattern String -> Pattern a \n")),(0,r.kt)("h3",{id:"spaceout"},"spaceOut"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spaceOut :: [Time] -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spaceOut xs p")," repeats a pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," at different durations given by the list of time values in ",(0,r.kt)("inlineCode",{parentName:"p"},"xs")," "),(0,r.kt)("h3",{id:"flatpat"},"flatpat"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"flatpat :: Pattern [a] -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"flatpat")," takes a Pattern of lists and pulls the list elements as\nseparate Events"),(0,r.kt)("h3",{id:"layer"},"layer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"layer :: [a -> Pattern b] -> a -> Pattern b \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"layer")," takes a Pattern of lists and pulls the list elements as\nseparate Events"),(0,r.kt)("h3",{id:"arpeggiate"},"arpeggiate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"arpeggiate :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"arpeggiate")," finds events that share the same timespan, and spreads\nthem out during that timespan, so for example ",(0,r.kt)("inlineCode",{parentName:"p"},'arpeggiate "[bd,sn]"'),"\ngets turned into ",(0,r.kt)("inlineCode",{parentName:"p"},'"bd sn"'),". Useful for creating arpeggios/broken chords."),(0,r.kt)("h3",{id:"arpg"},"arpg"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"arpg :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Shorthand alias for arpeggiate"),(0,r.kt)("h3",{id:"arpwith"},"arpWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"arpWith :: ([EventF (ArcF Time) a] -> [EventF (ArcF Time) b]) -> Pattern a -> Pattern b \n")),(0,r.kt)("h3",{id:"arp"},"arp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"arp :: Pattern String -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_arp"},"_arp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_arp :: String -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"rolledwith"},"rolledWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rolledWith :: Ratio Integer -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rolled")," plays each note of a chord quickly in order, as opposed to simultaneously; to give a chord a harp-like effect.\nThis will played from the lowest note to the highest note of the chord\n",(0,r.kt)("inlineCode",{parentName:"p"},'rolled $ n "cmaj4" # s "superpiano"')),(0,r.kt)("p",null,"And you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"rolledBy")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"rolledBy'")," to specify the length of the roll. The value in the passed pattern\nis the divisor of the cycle length. A negative value will play the arpeggio in reverse order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'rolledBy "-0.5 0.25 -0.125" $ note "c\'maj9" # s "superpiano"\n')),(0,r.kt)("h3",{id:"rolledby"},"rolledBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rolledBy :: Pattern (Ratio Integer) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"rolled"},"rolled"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rolled :: Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"ply"},"ply"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ply :: Pattern Rational -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_ply"},"_ply"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_ply :: Rational -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"plywith"},"plyWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"plyWith :: (Ord t, Num t) => Pattern t -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_plywith"},"_plyWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_plyWith :: (Ord t, Num t) => t -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"press"},"press"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"press :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Syncopates a rhythm, shifting each event halfway into its arc (aka timespan), e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"a b [c d] e"')," becomes the equivalent of ",(0,r.kt)("inlineCode",{parentName:"p"},'"[~ a] [~ b] [[~ c] [~ d]] [~ e]"')),(0,r.kt)("h3",{id:"pressby"},"pressBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pressBy :: Pattern Time -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Like ",(0,r.kt)("inlineCode",{parentName:"p"},"press"),", but allows you to specify the amount in which each event is shifted. ",(0,r.kt)("inlineCode",{parentName:"p"},"pressBy 0.5")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"press"),", while ",(0,r.kt)("inlineCode",{parentName:"p"},"pressBy (1/3)")," shifts each event by a third of its arc."),(0,r.kt)("h3",{id:"_pressby"},"_pressBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_pressBy :: Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"sew"},"sew"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sew :: Pattern Bool -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Uses the first (binary) pattern to switch between the following\ntwo patterns. The resulting structure comes from the source patterns, not the\nbinary pattern. See also ",(0,r.kt)("inlineCode",{parentName:"p"},"stitch"),"."),(0,r.kt)("h3",{id:"stitch"},"stitch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stitch :: Pattern Bool -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Uses the first (binary) pattern to switch between the following\ntwo patterns. The resulting structure comes from the binary\npattern, not the source patterns. See also ",(0,r.kt)("inlineCode",{parentName:"p"},"sew"),"."),(0,r.kt)("h3",{id:"while"},"while"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"while :: Pattern Bool -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"A binary pattern is used to conditionally apply a function to a\nsource pattern. The function is applied when a ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," value is\nactive, and the pattern is let through unchanged when a ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"\nvalue is active. No events are let through where no binary values\nare active."),(0,r.kt)("h3",{id:"stutter"},"stutter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stutter :: Integral i => i -> Time -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"jux"},"jux"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jux :: (Pattern ValueMap -> Pattern ValueMap) -> Pattern ValueMap -> Pattern ValueMap \n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"jux")," function creates strange stereo effects, by applying a\nfunction to a pattern, but only in the right-hand channel. For\nexample, the following reverses the pattern on the righthand side:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 32 $ jux (rev) $ striateBy 32 (1/16) $ sound "bev"\n')),(0,r.kt)("p",null,"When passing pattern transforms to functions like jux and every,\nit's possible to chain multiple transforms together with ",(0,r.kt)("inlineCode",{parentName:"p"},"."),", for\nexample this both reverses and halves the playback speed of the\npattern in the righthand channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 32 $ jux ((# speed "0.5") . rev) $ striateBy 32 (1/16) $ sound "bev"\n')),(0,r.kt)("h3",{id:"juxcut"},"juxcut"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"juxcut :: (Pattern ValueMap -> Pattern ValueMap) -> Pattern ValueMap -> Pattern ValueMap \n")),(0,r.kt)("h3",{id:"juxcut-1"},"juxcut'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"juxcut' :: [t -> Pattern ValueMap] -> t -> Pattern ValueMap \n")),(0,r.kt)("h3",{id:"jux-1"},"jux'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jux' :: [t -> Pattern ValueMap] -> t -> Pattern ValueMap \n")),(0,r.kt)("p",null,"In addition to ",(0,r.kt)("inlineCode",{parentName:"p"},"jux"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"jux'")," allows using a list of pattern transform. resulting patterns from each transformation will be spread via pan from left to right."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ jux\' [iter 4, chop 16, id, rev, palindrome] $ sound "bd sn"\n')),(0,r.kt)("p",null,"will put ",(0,r.kt)("inlineCode",{parentName:"p"},"iter 4")," of the pattern to the far left and ",(0,r.kt)("inlineCode",{parentName:"p"},"palindrome")," to the far right. In the center the original pattern will play and mid left mid right the chopped and the reversed version will appear."),(0,r.kt)("p",null,"One could also write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ stack [\n    iter 4 $ sound "bd sn" # pan "0",\n    chop 16 $ sound "bd sn" # pan "0.25",\n    sound "bd sn" # pan "0.5",\n    rev $ sound "bd sn" # pan "0.75",\n    palindrome $ sound "bd sn" # pan "1",\n    ]\n')),(0,r.kt)("h3",{id:"jux4"},"jux4"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jux4 :: (Pattern ValueMap -> Pattern ValueMap) -> Pattern ValueMap -> Pattern ValueMap \n")),(0,r.kt)("p",null,"Multichannel variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"jux"),", ",(0,r.kt)("em",{parentName:"p"},"not sure what it does")),(0,r.kt)("h3",{id:"juxby"},"juxBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"juxBy :: Pattern Double -> (Pattern ValueMap -> Pattern ValueMap) -> Pattern ValueMap -> Pattern ValueMap \n")),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"jux"),", the original and effected versions of the pattern are\npanned hard left and right (i.e., panned at 0 and 1). This can be a\nbit much, especially when listening on headphones. The variant ",(0,r.kt)("inlineCode",{parentName:"p"},"juxBy"),"\nhas an additional parameter, which brings the channel closer to the\ncentre. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ juxBy 0.5 (density 2) $ sound "bd sn:1"\n')),(0,r.kt)("p",null,"In the above, the two versions of the pattern would be panned at 0.25\nand 0.75, rather than 0 and 1."),(0,r.kt)("h3",{id:"pick"},"pick"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pick :: String -> Int -> String \n")),(0,r.kt)("h3",{id:"samples"},"samples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"samples :: Applicative f => f String -> f Int -> f String \n")),(0,r.kt)("h3",{id:"samples-1"},"samples'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"samples' :: Applicative f => f String -> f Int -> f String \n")),(0,r.kt)("h3",{id:"spreadf"},"spreadf"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"spreadf :: [a -> Pattern b] -> a -> Pattern b \n")),(0,r.kt)("h3",{id:"stackwith"},"stackwith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stackwith :: Unionable a => Pattern a -> [Pattern a] -> Pattern a \n")),(0,r.kt)("h3",{id:"range"},"range"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"range :: Num a => Pattern a -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"range")," will take a pattern which goes from 0 to 1 (like ",(0,r.kt)("inlineCode",{parentName:"p"},"sine"),"), and range it to a different range - between the first and second arguments. In the below example, ",(0,r.kt)("inlineCode",{parentName:"p"},"range 1 1.5")," shifts the range of ",(0,r.kt)("inlineCode",{parentName:"p"},"sine1")," from 0 - 1 to 1 - 1.5."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ jux (iter 4) $ sound "arpy arpy:2*2"\n  |+ speed (slow 4 $ range 1 1.5 sine1)\n')),(0,r.kt)("h3",{id:"_range"},"_range"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_range :: (Functor f, Num b) => b -> b -> f b -> f b \n")),(0,r.kt)("h3",{id:"rangex"},"rangex"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rangex :: (Functor f, Floating b) => b -> b -> f b -> f b \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rangex")," is an exponential version of ",(0,r.kt)("inlineCode",{parentName:"p"},"range"),", good for using with\nfrequencies.  Do ",(0,r.kt)("em",{parentName:"p"},"not")," use negative numbers or zero as arguments! "),(0,r.kt)("h3",{id:"off"},"off"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"off :: Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_off"},"_off"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_off :: Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"offadd"},"offadd"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"offadd :: Num a => Pattern Time -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"step"},"step"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"step :: String -> String -> Pattern String \n")),(0,r.kt)("p",null,"Step sequencing"),(0,r.kt)("h3",{id:"steps"},"steps"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"steps :: [(String, String)] -> Pattern String \n")),(0,r.kt)("h3",{id:"step-1"},"step'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"step' :: [String] -> String -> Pattern String \n")),(0,r.kt)("p",null,"like ",(0,r.kt)("inlineCode",{parentName:"p"},"step"),", but allows you to specify an array of strings to use for 0,1,2..."),(0,r.kt)("h3",{id:"ghost"},"ghost''"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ghost'' :: Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"ghost-1"},"ghost'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ghost' :: Time -> Pattern ValueMap -> Pattern ValueMap \n")),(0,r.kt)("h3",{id:"ghost-2"},"ghost"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ghost :: Pattern ValueMap -> Pattern ValueMap \n")),(0,r.kt)("h3",{id:"tabby"},"tabby"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"tabby :: Int -> Pattern a -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"tabby - A more literal weaving than the ",(0,r.kt)("inlineCode",{parentName:"p"},"weave")," function, give number\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"threads")," per cycle and two patterns, and this function will weave them\ntogether using a plain (aka ",(0,r.kt)("inlineCode",{parentName:"p"},"tabby"),") weave, with a simple over/under structure"),(0,r.kt)("h3",{id:"select"},"select"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"select :: Pattern Double -> [Pattern a] -> Pattern a \n")),(0,r.kt)("p",null,"chooses between a list of patterns, using a pattern of floats (from 0-1)"),(0,r.kt)("h3",{id:"_select"},"_select"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_select :: Double -> [Pattern a] -> Pattern a \n")),(0,r.kt)("h3",{id:"selectf"},"selectF"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"selectF :: Pattern Double -> [Pattern a -> Pattern a] -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"chooses between a list of functions, using a pattern of floats (from 0-1)"),(0,r.kt)("h3",{id:"_selectf"},"_selectF"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_selectF :: Double -> [Pattern a -> Pattern a] -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"pickf"},"pickF"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pickF :: Pattern Int -> [Pattern a -> Pattern a] -> Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"chooses between a list of functions, using a pattern of integers"),(0,r.kt)("h3",{id:"_pickf"},"_pickF"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_pickF :: Int -> [Pattern a -> Pattern a] -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"contrast"},"contrast"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"contrast :: (ControlPattern -> ControlPattern) -> (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"contrast p f f' p'")," splits controlpattern ",(0,r.kt)("inlineCode",{parentName:"p"},"p'")," in two, applying\nthe function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," to one and ",(0,r.kt)("inlineCode",{parentName:"p"},"f'")," to the other. This depends on\nwhether events in it contains values matching with those in ",(0,r.kt)("inlineCode",{parentName:"p"},"p"),".\nFor example in ",(0,r.kt)("inlineCode",{parentName:"p"},'contrast (# crush 3) (# vowel "a") (n "1") $ n "0 1" # s "bd sn" # speed 3'),",\nthe first event will have the vowel effect applied and the second\nwill have the crush applied."),(0,r.kt)("h3",{id:"contrastby"},"contrastBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"contrastBy :: (a -> Value -> Bool) -> (ControlPattern -> Pattern b) -> (ControlPattern -> Pattern b) -> Pattern (Map String a) -> Pattern (Map String Value) -> Pattern b \n")),(0,r.kt)("h3",{id:"contrastrange"},"contrastRange"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"contrastRange :: (ControlPattern -> Pattern a) -> (ControlPattern -> Pattern a) -> Pattern (Map String (Value, Value)) -> ControlPattern -> Pattern a \n")),(0,r.kt)("h3",{id:"fix"},"fix"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fix :: (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"Like ",(0,r.kt)("inlineCode",{parentName:"p"},"contrast"),", but one function is given, and applied to events with matching controls."),(0,r.kt)("h3",{id:"unfix"},"unfix"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"unfix :: (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern \n")),(0,r.kt)("p",null,"Like ",(0,r.kt)("inlineCode",{parentName:"p"},"contrast"),", but one function is given, and applied to events\nwith controls which don't match."),(0,r.kt)("h3",{id:"fixrange"},"fixRange"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fixRange :: (ControlPattern -> Pattern ValueMap) -> Pattern (Map String (Value, Value)) -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"unfixrange"},"unfixRange"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"unfixRange :: (ControlPattern -> Pattern ValueMap) -> Pattern (Map String (Value, Value)) -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"quantise"},"quantise"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"quantise :: (Functor f, RealFrac b) => b -> f b -> f b \n")),(0,r.kt)("p",null,"limit values in a Pattern (or other Functor) to n equally spaced\ndivisions of 1."),(0,r.kt)("h3",{id:"qfloor"},"qfloor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"qfloor :: (Functor f, RealFrac b) => b -> f b -> f b \n")),(0,r.kt)("h3",{id:"qceiling"},"qceiling"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"qceiling :: (Functor f, RealFrac b) => b -> f b -> f b \n")),(0,r.kt)("h3",{id:"qround"},"qround"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"qround :: (Functor f, RealFrac b) => b -> f b -> f b \n")),(0,r.kt)("h3",{id:"inv"},"inv"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"inv :: Functor f => f Bool -> f Bool \n")),(0,r.kt)("p",null,"Inverts all the values in a boolean pattern"),(0,r.kt)("h3",{id:"mono"},"mono"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mono :: Pattern a -> Pattern a \n")),(0,r.kt)("p",null,"Serialises a pattern so there's only one event playing at any one\ntime, making it ",(0,r.kt)("inlineCode",{parentName:"p"},"monophonic"),". Events which start/end earlier are given priority."),(0,r.kt)("h3",{id:"smooth"},"smooth"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"smooth :: Fractional a => Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"swap"},"swap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"swap :: Eq a => [(a, b)] -> Pattern a -> Pattern b \n")),(0,r.kt)("p",null,"Looks up values from a list of tuples, in order to swap values in the given pattern"),(0,r.kt)("h3",{id:"snowball"},"snowball"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"snowball :: Int -> (Pattern a -> Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"soak"},"soak"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"soak :: Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"deconstruct"},"deconstruct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"deconstruct :: Int -> Pattern String -> String \n")),(0,r.kt)("h3",{id:"bite"},"bite"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bite :: Pattern Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"_bite"},"_bite"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_bite :: Int -> Pattern Int -> Pattern a -> Pattern a \n")),(0,r.kt)("h3",{id:"squeeze"},"squeeze"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"squeeze :: Pattern Int -> [Pattern a] -> Pattern a \n")),(0,r.kt)("h3",{id:"squeezejoinup"},"squeezeJoinUp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"squeezeJoinUp :: Pattern ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"_chew"},"_chew"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_chew :: Int -> Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"chew"},"chew"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"chew :: Pattern Int -> Pattern Int -> ControlPattern -> ControlPattern \n")),(0,r.kt)("h3",{id:"__binary"},"__binary"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"__binary :: Bits b => Int -> b -> [Bool] \n")),(0,r.kt)("h3",{id:"_binary"},"_binary"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_binary :: Bits b => Int -> b -> Pattern Bool \n")),(0,r.kt)("h3",{id:"_binaryn"},"_binaryN"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"_binaryN :: Int -> Pattern Int -> Pattern Bool \n")),(0,r.kt)("h3",{id:"binaryn"},"binaryN"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"binaryN :: Pattern Int -> Pattern Int -> Pattern Bool \n")),(0,r.kt)("h3",{id:"binary"},"binary"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"binary :: Pattern Int -> Pattern Bool \n")),(0,r.kt)("h3",{id:"ascii"},"ascii"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ascii :: Pattern String -> Pattern Bool \n")),(0,r.kt)("h3",{id:"grain"},"grain"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"grain :: Pattern Double -> Pattern Double -> ControlPattern \n")),(0,r.kt)("h3",{id:"necklace"},"necklace"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"necklace :: Rational -> [Int] -> Pattern Bool \n")),(0,r.kt)("p",null,"For specifying a boolean pattern according to a list of offsets\n(aka inter-onset intervals).  For example ",(0,r.kt)("inlineCode",{parentName:"p"},"necklace 12 [4,2]"),' is\nthe same as "t f f f t f t f f f t f". That is, 12 steps per cycle,\nwith true values alternating between every 4 and every 2 steps.'))}u.isMDXComponent=!0}}]);