"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[225],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},s="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),s=d(n),m=r,k=s["".concat(p,".").concat(m)]||s[m]||c[m]||i;return n?a.createElement(k,l(l({ref:t},u),{},{components:n})):a.createElement(k,l({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[s]="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9535:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>s,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(3117),r=(n(7294),n(3905));const i={title:"Sound.Tidal.Transition",slug:"/library/modules/Sound.Tidal.Transition"},l=void 0,o={unversionedId:"library/autogenerated/Sound-Tidal-Transition/Sound-Tidal-Transition",id:"library/autogenerated/Sound-Tidal-Transition/Sound-Tidal-Transition",title:"Sound.Tidal.Transition",description:"\x3c!------------------------------------------------------------------------------",source:"@site/docs/library/autogenerated/Sound-Tidal-Transition/Sound-Tidal-Transition.mdx",sourceDirName:"library/autogenerated/Sound-Tidal-Transition",slug:"/library/modules/Sound.Tidal.Transition",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Transition",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/library/autogenerated/Sound-Tidal-Transition/Sound-Tidal-Transition.mdx",tags:[],version:"current",lastUpdatedBy:"Matthew Kaney",lastUpdatedAt:1673207986,formattedLastUpdatedAt:"Jan 8, 2023",frontMatter:{title:"Sound.Tidal.Transition",slug:"/library/modules/Sound.Tidal.Transition"},sidebar:"library",previous:{title:"Sound.Tidal.Time",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.Time"},next:{title:"Sound.Tidal.UI",permalink:"/tidal-doc/docs/library/modules/Sound.Tidal.UI"}},p={},d=[{value:"transition",id:"transition",level:3},{value:"mortalOverlay",id:"mortaloverlay",level:3},{value:"wash",id:"wash",level:3},{value:"washIn",id:"washin",level:3},{value:"xfadeIn",id:"xfadein",level:3},{value:"histpan",id:"histpan",level:3},{value:"wait",id:"wait",level:3},{value:"waitT",id:"waitt",level:3},{value:"jump",id:"jump",level:3},{value:"jumpIn",id:"jumpin",level:3},{value:"jumpIn&#39;",id:"jumpin-1",level:3},{value:"jumpMod",id:"jumpmod",level:3},{value:"jumpMod&#39;",id:"jumpmod-1",level:3},{value:"mortal",id:"mortal",level:3},{value:"interpolate",id:"interpolate",level:3},{value:"interpolateIn",id:"interpolatein",level:3},{value:"clutch",id:"clutch",level:3},{value:"clutchIn",id:"clutchin",level:3},{value:"anticipateIn",id:"anticipatein",level:3},{value:"anticipate",id:"anticipate",level:3}],u={toc:d};function s(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"transition"},"transition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"transition :: Stream -> Bool -> (Time -> [ControlPattern] -> ControlPattern) -> ID -> ControlPattern -> IO () \n")),(0,r.kt)("h3",{id:"mortaloverlay"},"mortalOverlay"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mortalOverlay :: Time -> Time -> [Pattern a] -> Pattern a \n")),(0,r.kt)("h3",{id:"wash"},"wash"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wash :: (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Time -> Time -> Time -> Time -> [Pattern a] -> Pattern a \n")),(0,r.kt)("p",null,"Washes away the current pattern after a certain delay by applying a\nfunction to it over time, then switching over to the next pattern to\nwhich another function is applied."),(0,r.kt)("h3",{id:"washin"},"washIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"washIn :: (Pattern a -> Pattern a) -> Time -> Time -> [Pattern a] -> Pattern a \n")),(0,r.kt)("h3",{id:"xfadein"},"xfadeIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"xfadeIn :: Time -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("h3",{id:"histpan"},"histpan"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"histpan :: Int -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Pans the last n versions of the pattern across the field"),(0,r.kt)("h3",{id:"wait"},"wait"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wait :: Time -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Just stop for a bit before playing new pattern"),(0,r.kt)("h3",{id:"waitt"},"waitT"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"waitT :: (Time -> [ControlPattern] -> ControlPattern) -> Time -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Just as ",(0,r.kt)("inlineCode",{parentName:"p"},"wait"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"waitT")," stops for a bit and then applies the given transition to the playing pattern"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd"\n\nt1 (waitT (xfadeIn 8) 4) $ sound "hh*8"\n')),(0,r.kt)("h3",{id:"jump"},"jump"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jump :: Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Jumps directly into the given pattern, this is essentially the ",(0,r.kt)("em",{parentName:"p"},"no transition"),"-transition."),(0,r.kt)("p",null,"Variants of ",(0,r.kt)("inlineCode",{parentName:"p"},"jump")," provide more useful capabilities, see ",(0,r.kt)("inlineCode",{parentName:"p"},"jumpIn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jumpMod")),(0,r.kt)("h3",{id:"jumpin"},"jumpIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jumpIn :: Int -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Sharp ",(0,r.kt)("inlineCode",{parentName:"p"},"jump")," transition after the specified number of cycles have passed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'t1 (jumpIn 2) $ sound "kick(3,8)"\n')),(0,r.kt)("h3",{id:"jumpin-1"},"jumpIn'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jumpIn' :: Int -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("inlineCode",{parentName:"p"},"jumpIn")," the variant ",(0,r.kt)("inlineCode",{parentName:"p"},"jumpIn'")," will only transition at cycle boundary (e.g. when the cycle count is an integer)."),(0,r.kt)("h3",{id:"jumpmod"},"jumpMod"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jumpMod :: Int -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Sharp ",(0,r.kt)("inlineCode",{parentName:"p"},"jump")," transition at next cycle boundary where cycle mod n == 0"),(0,r.kt)("h3",{id:"jumpmod-1"},"jumpMod'"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"jumpMod' :: Int -> Int -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Sharp ",(0,r.kt)("inlineCode",{parentName:"p"},"jump")," transition at next cycle boundary where cycle mod n == p"),(0,r.kt)("h3",{id:"mortal"},"mortal"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mortal :: Time -> Time -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"Degrade the new pattern over time until it ends in silence"),(0,r.kt)("h3",{id:"interpolate"},"interpolate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interpolate :: Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("h3",{id:"interpolatein"},"interpolateIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interpolateIn :: Time -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("h3",{id:"clutch"},"clutch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"clutch :: Time -> [Pattern a] -> Pattern a \n")),(0,r.kt)("p",null,"Degrades the current pattern while undegrading the next."),(0,r.kt)("p",null,"This is like ",(0,r.kt)("inlineCode",{parentName:"p"},"xfade")," but not by gain of samples but by randomly removing events from the current pattern and slowly adding back in missing events from the next one."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd(3,8)"\n\nt1 clutch $ sound "[hh*4, odx(3,8)]"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"clutch")," takes two cycles for the transition, essentially this is ",(0,r.kt)("inlineCode",{parentName:"p"},"clutchIn 2"),"."),(0,r.kt)("h3",{id:"clutchin"},"clutchIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"clutchIn :: Time -> Time -> [Pattern a] -> Pattern a \n")),(0,r.kt)("p",null,"Also degrades the current pattern and undegrades the next.\nTo change the number of cycles the transition takes, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"clutchIn")," like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd(5,8)"\n\nt1 (clutchIn 8) $ sound "[hh*4, odx(3,8)]"\n')),(0,r.kt)("p",null,"will take 8 cycles for the transition."),(0,r.kt)("h3",{id:"anticipatein"},"anticipateIn"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"anticipateIn :: Time -> Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,"same as ",(0,r.kt)("inlineCode",{parentName:"p"},"anticipate")," though it allows you to specify the number of cycles until dropping to the new pattern, e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "jvbass(3,8)"\n\nt1 (anticipateIn 4) $ sound "jvbass(5,8)"\n')),(0,r.kt)("h3",{id:"anticipate"},"anticipate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"anticipate :: Time -> [ControlPattern] -> ControlPattern \n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"anticipate")," is an increasing comb filter."),(0,r.kt)("p",null,"Build up some tension, culminating in a ",(0,r.kt)("em",{parentName:"p"},"drop")," to the new pattern after 8 cycles."))}s.isMDXComponent=!0}}]);